<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Askunix&#39;s Blog</title>
  
  <subtitle>谋无主则困 事无备则废</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://askunix.github.io/"/>
  <updated>2018-08-23T04:18:53.829Z</updated>
  <id>http://askunix.github.io/</id>
  
  <author>
    <name>何进鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件压缩（基于Huffman树实现无损压缩）</title>
    <link href="http://askunix.github.io/2018/08/20/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    <id>http://askunix.github.io/2018/08/20/文件压缩/</id>
    <published>2018-08-20T15:38:51.000Z</published>
    <updated>2018-08-23T04:18:53.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>项目采用Huffman编码的方式进行文件压缩与解压缩。主要原理是通过Huffman编码来表示字符，出现次数多的编码短，出现次数少的编码长，这样整体而言，所需要的bit位是减少的，就实现了文件压缩功能。</li><li>读取文件中的字符出现次数，构建Huffman树，然后解析这个字符的每一位，遇到一个叶子结点，就代表还原了一个字符，这时就将这个字符写到解压缩文件里。</li><li>3、注意当大部分字符出现的频率都差不多时，Huffman压缩的效率比较低。<a id="more"></a></li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>  输入：文本文件(压缩文件)</p><p>  输出：压缩文件/解压文件(文本文件)  (压缩时间)</p><p>  知识点：堆、霍夫曼树、二叉树遍历、存储数据结构设计、文件流操作、字符汉字编码方式、二进制文件读写、优先级队列。</p><h4 id="模块及框架设计"><a href="#模块及框架设计" class="headerlink" title="模块及框架设计"></a>模块及框架设计</h4><p>主要模块：</p><p>1、压缩模块<br>2、解压模块</p><p>辅助模块：</p><p>1、字符识别及权重获取<br>2、Huffman树构造<br>3、获取huffman编码</p><h4 id="压缩步骤"><a href="#压缩步骤" class="headerlink" title="压缩步骤"></a>压缩步骤</h4><p>1、统计字符出现的次数</p><p>因为文件底层都是有256个字符存储的，所以使用一个256的数组来统计字符出现的次数。在项目中，使用了一个结构体，将次数、字符、huffman编码对应起来。因为不管是文件、图片、音频、视频。他们的底层都是以字符形式存储的，读取的时候就按照字符格式读取。</p><p>2、构建huffman树</p><p>采用Huffman编码，将一组集合中权值最小的两棵树拿出来构建一棵树，选择权值最小的两棵树拿出来构建一棵树，再将权值之和作为节点插入到这个集合中，不断重复，直到集合中只有一个树，寻找最小的两棵树，利用了priority_queue，在这里将字符出现的次数作为权值。</p><p>3、生成huffman编码</p><p>从根节点出发，向左走为0，向右走为1，每次走一步，都将这个节点的huffman编码存储下来，直到走到叶子结点，huffman编码就能用递归直接获得。</p><p>4、将Huffman编码写入文件</p><p>使用哈希表，可以实现在O(1)时间内找到字符对应的编码，将每八位编码构成一个字符按“位”写入文件中。如果最后几位不够8位，在后面补0。最后解码时，根据字符个数，实现解压缩，总的字符个数就是Huffman数根节点的权值。</p><h4 id="解压缩步骤"><a href="#解压缩步骤" class="headerlink" title="解压缩步骤"></a>解压缩步骤</h4><p>1、读取解压文件<br>读取文件中每个字符出现的次数，便于还原Huffman树。</p><p>2、构建huffman树<br>构建Huffman树和压缩时的构建是一样的。</p><p>3、解压</p><p>首先在压缩文件中读取一个字符，然后解析这个字符的每一位，遇到一个叶子结点，就代表还原了一个字符，这时就将这个字符写到解压缩文件里。需要注意的是此时最后几位编码可能是自己补上去的，所以要用源文件中字符出现的次数来控制解压缩，根据Huffman性质可知，根节点权重就是字符出现的次数。</p><h4 id="项目中遇到的问题"><a href="#项目中遇到的问题" class="headerlink" title="项目中遇到的问题"></a>项目中遇到的问题</h4><p>1、解压缩时解压不完全</p><p>由于使用文本形式读取压缩文件，有可能提前遇到文件结束标志，所以要改为二进制形式读写。二进制形式是读取二进制编码。</p><p>如果以文本形式读取的话，回车会被当成一个字符’\n’，而二进制形式则会认为它是两个字符即’\r’回车、’\n’换行；如果在文本形式中遇到0x1B的话，文本形式会认为这是文本结束符，而二进制模型则不会对它产生处理。</p><p>2、得到huffman编码</p><p>在压缩时我们要求解huffman编码，在这里可以使用stl中的string和reverse求解。也可以使用后序递归直接求解。</p><p>3、压缩汉字时出现问题<br>因为汉字是由多个字符表示，这些字符的范围是0—255,所以在结构体中要用unsigned char表示。</p><p> 4、对文本文件最后一个字符的处理<br> 补位数：压缩，解压无错误</p><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><p>1、解压缩的时候有可能要解压缩文件的不是用huffman进行压缩的文件。所以再解压文件之前先判断是不是用huffman进行压缩的。</p><p>2、不使用配置文件时如何解压<br>    可以将huffman树的信息写入到压缩文件中。</p><p>####项目扩展<br>1、实现对文件夹的压缩<br>对文件夹进行压缩实际上还是对文件夹中的内容进行压缩，所以得到一个文件夹之后我们就一直向子文件夹中找，直到找到文件后进行压缩就可以了。<br>2、解压缩的时候要将文件夹还原出来。</p><h4 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h4><p>1、使用ifstrem和ofsteam函数对文本进行输出输入操作时，最好写成以二进制方式，否则可能会出现读取到特殊符号而终止，导致解压缩不完全，二进制方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(filename,ios::in|ios::binary)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(filename,ios::out|ios::binary)</span></span>;</span><br></pre></td></tr></table></figure><p>2、对字符进行直接定址确定自己在哈希表中的位置时，要注意使用(unsigend char)ch强转，因为哈希表的定义范围是0到255，而字符的大小是-127到128</p><p>3、创建huffman树时，因为节点中保存的是一个结构体而不是一个简单的内置类型，因此在对节点进行“比较”操作的时候需要自己重载这些比较操作符，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> T&amp; t);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> T&amp; t);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;项目采用Huffman编码的方式进行文件压缩与解压缩。主要原理是通过Huffman编码来表示字符，出现次数多的编码短，出现次数少的编码长，这样整体而言，所需要的bit位是减少的，就实现了文件压缩功能。&lt;/li&gt;
&lt;li&gt;读取文件中的字符出现次数，构建Huffman树，然后解析这个字符的每一位，遇到一个叶子结点，就代表还原了一个字符，这时就将这个字符写到解压缩文件里。&lt;/li&gt;
&lt;li&gt;3、注意当大部分字符出现的频率都差不多时，Huffman压缩的效率比较低。
    
    </summary>
    
      <category term="小项目" scheme="http://askunix.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="文件压缩" scheme="http://askunix.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="Huffman树" scheme="http://askunix.github.io/tags/Huffman%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>揭开智能指针底层面纱</title>
    <link href="http://askunix.github.io/2018/08/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://askunix.github.io/2018/08/05/智能指针/</id>
    <published>2018-08-05T15:38:51.000Z</published>
    <updated>2018-08-05T14:41:31.391Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>介绍三个智能指针：unique_ptr、shared_ptr、weak_ptr。auto_ptr已经被C++11丢弃了。</li><li>C++的内存管理中，当我们写一个new语句时，一般立即跟一个delete，但是也很难保证没有运行到delete就返回了。申请的资源没有释放，就会造成内存泄露，所以就有了智能指针。<a id="more"></a></li></ul><p><strong>智能指针解决了哪些问题：</strong></p><p>1、忘记调用delete释放内存。</p><p>2、程序异常的进入catch块忘记释放内存。</p><p>3、指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</p><h4 id="为什么不建议使用auto-ptr？"><a href="#为什么不建议使用auto-ptr？" class="headerlink" title="为什么不建议使用auto_ptr？"></a>为什么不建议使用auto_ptr？</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; px(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; py;</span><br><span class="line">py = px;</span><br></pre></td></tr></table></figure><p>如果px和py是普通指针，则两个指针将指向同一个动态分配的int对象。这是不能接受的，因为程序可能将试图删除同一个对象两次——一次是px过期时，另一次是py过期时，我们知道，同一块内存是不能delete两次的。要避免这种问题，主要有以下两种方法：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/jjjjjjjjjjjj.jpg" alt="这里写图片描述"></p><p>C++11中为什么建议摒弃auto_ptr，看下面的例子：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/kkkkkkkkkkkkk.jpg" alt="这里写图片描述"></p><p>从程序的运行结果来看，当执行完赋值语句py = px后，再去访问px时程序崩溃了。原因就是因为赋值语句py = px使得对象的所有权从px转让给py了，px已经变为空指针了，再去访问px当然会出错了。</p><ul><li>是怎么样交给被赋值的指针的呢？</li></ul><p>auto_ptr重载了等号操作符，由图可知意思是把赋值智能指针的内存交给被赋值智能指针，如下：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/zzzzzzzzzzzzz.jpg" alt="这里写图片描述"></p><ul><li>那么如果使用unique_ptr或者shared_ptr又会怎样了？还是测试下吧，先看unique_ptr情况：</li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/llllllll.jpg" alt="这里写图片描述"></p><p>如果使用unique_ptr，在这种情况下编译会出错，也就是说尽管与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，在编译时就将可能潜在的错误暴露给你。</p><ul><li>再看看shared_ptr情况：</li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/wwwwwww.jpg" alt="这里写图片描述"></p><p>使用shared_ptr时运行正常，因为shared_ptr采用引用计数，当执行完赋值语句py = px后，px和py都指向同一块内存，只不过在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。</p><h4 id="如何选择哪种智能指针？"><a href="#如何选择哪种智能指针？" class="headerlink" title="如何选择哪种智能指针？"></a>如何选择哪种智能指针？</h4><p><img src="http://p9ff104hp.bkt.clouddn.com/xxxxxxxx.jpg" alt="这里写图片描述"></p><hr><p><img src="http://p9ff104hp.bkt.clouddn.com/ggggggggggggg.jpg" alt="这里写图片描述"></p><p>####</p><h4 id="unique-ptr："><a href="#unique-ptr：" class="headerlink" title="unique_ptr："></a>unique_ptr：</h4><p> C++11引入了许多便捷的功能，其中也包括这个，在用之前我们可以先看下底层：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/3333333333333333333333333333333333333333333333333.jpg" alt="这里写图片描述"></p><p>可以清楚的看到，unique_ptr中的拷贝构造和赋值操作符delete了，所以也就意味着，他和auto_ptr有区别，控制权唯一，不能随意转换。用法都差不多：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Base1&gt; base1(<span class="keyword">new</span> Base1);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Base1&gt;base2;<span class="comment">//但是不能用拷贝构造和等号赋值把base1赋值给base2了</span></span><br></pre></td></tr></table></figure><p>但是如果想切换控制权的话也不是没有办法，我们可以看到还有个这样的函数：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/77777777777777.jpg" alt="这里写图片描述"></p><p>要理解这两个函数，首先要理解c++11引入的move和forward；而要理解move和forward得先理解左值和右值概念。所以还是讲全一点吧（已经了解的就直接跳过可以）：</p><h5 id="补充知识点："><a href="#补充知识点：" class="headerlink" title="补充知识点："></a>补充知识点：</h5><p>1、左值与右值：</p><p> 左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)。需要注意的是，左值是指表达式结束后依然存在的持久对象，而右值是指表达式结束时就不再存在的临时对象。T&amp; 指向的是 lvalue，而 const T&amp; 指向的，却可能是 lvalue 或 rvalue，左值引用&amp;与右值引用&amp;&amp;（右值引用是c++11加上的）。</p><p>2、move和forward：</p><p> 需要明确的是，move函数可以是用于构造函数，也可以用于赋值函数，但都需要手动显示添加。其实move函数用直白点的话来说就是省去拷贝构造和赋值时中间的临时对象，将资源的内存从一个对象移动到（共享也可以）另一个对象。官话是：c++11 中的 move() 是这样一个函数，它接受一个参数，然后返回一个该参数对应的右值引用。</p><p>  std::forward<t>(u) 有两个参数：T 与 u。当T为左值引用类型时，u将被转换为T类型的左值，否则u将被转换为T类型右值。如此定义std::forward是为了在使用右值引用参数的函数模板中解决参数的完美转发问题。</t></p><p>其实这里说的不够清晰，下次翻译一篇国外的解释，阅读下来就能很好理解move这个概念了，这里先不深入。</p><p>回到这张图，这两个函数体也就很明朗了——重载move版本的拷贝构造函数以及重载move版本的等号赋值函数。</p><p>意思就是：把右值的对象（right）移动给左值（_myt&amp;），并且右值清空。</p><p>那么用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;Base1&gt;base1(<span class="keyword">new</span> Base1);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Base1&gt;base2=move(base1);<span class="comment">//base1变成empty</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;Base1&gt;base3;</span><br><span class="line">base3 = move(base2);<span class="comment">//base2变成empty</span></span><br></pre></td></tr></table></figure><p>其它的成员函数就不一一赘述，和auto_ptr大致上是相同的。总结，某种程度来说比auto_ptr更为安全，适用部分特殊情况。</p><h4 id="shared-ptr："><a href="#shared-ptr：" class="headerlink" title="shared_ptr："></a>shared_ptr：</h4><p>如果完全理解了上面两个ptr的底层，那么shared_ptr的也就容易理解多了。但是和前两者有很大区别——前两者控制权唯一，切换的时候把前面的清除。而shared_ptr不会，照例看下底层：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/888888888888.jpg" alt="这里写图片描述"></p><p>很显然，可以直接赋值和调用拷贝构造函数，且不会清空原本的智能指针。用法就很简单了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Base1&gt;base1(<span class="keyword">new</span> Base1);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Base1&gt;base2=base1;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Base1&gt;base3;</span><br><span class="line">base3 = base2;<span class="comment">//三个共享一个</span></span><br></pre></td></tr></table></figure><ul><li>有个地方需要注意，当删除一个智能指针时，并不影响其它两个智能指针的继续使用。因为该片内存添加了一个引用计数，每shared_ptr一次，引用计数+1；每次调用析构函数，引用计数减一。直到最后一个智能指针删除，才会释放内存。</li></ul><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>1、在继续查看时，你会发现以下两个函数：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/000000000.jpg" alt="这里写图片描述"></p><p>其实就是和unique_ptr一样可以通过move来切换控制权，这个时候是切换，不是共享了。</p><p>2、接下来继续翻看，还有两个函数：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/1112222.jpg" alt="这里写图片描述"></p><p>（其实auto_ptr也有，只是一样，没必要截图了）也就是说，auto_ptr和unique_ptr都可以通过move函数转换成shared_ptr类型，当然，一样是切换控制权的形式，即旧的置空。</p><p>用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;Base1&gt;base1(<span class="keyword">new</span> Base1);</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;Base1&gt;base2=move(base1);</span><br></pre></td></tr></table></figure><h5 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h5><p>shared_ptr多个指针指向相同的对象。shared_ptr使用计数机制来表明资源被几个指针共享，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p><ul><li><p>初始化。<br>智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptr<int> p4 = new int(1);的写法是错误的</int></p></li><li><p>拷贝和赋值。<br>拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。</p></li><li><p>注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存。</p></li><li><p>get函数获取原始指针；可以通过成员函数use_count()来查看资源的所有者个数。</p></li><li><p>注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</p></li></ul><h4 id="weak-ptr："><a href="#weak-ptr：" class="headerlink" title="weak_ptr："></a>weak_ptr：</h4><p>weak_ptr更像是shared_ptr的助手：</p><p>1、他不像其余三种，可以通过构造函数直接分配对象内存；他必须通过shared_ptr来共享内存。</p><p>2、没有重载opreator*和-&gt;操作符，也就意味着即使分配到对象，他也没法使用该对象</p><p>3、不主动参与引用计数，即，share_ptr释放了，那么weak_ptr所存的对象也释放了。</p><p>4、使用成员函数use_count()可以查看当前引用计数，expired()判断引用计数是否为空。</p><p>5、lock()函数，返回一个shared_ptr智能指针：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/1111111111111111.jpg" alt="这里写图片描述"></p><p>也就是让weak_ptr观测shared_ptr智能指针，并且在需要时候通过lock函数返回一个shared_ptr。</p><p>文章大部分参考网上的博客。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>如上讲了这么多智能指针，有必要对这些智能指针做个总结：</p><p>1、在可以使用 boost 库的场合下，拒绝使用 std::auto_ptr，因为其不仅不符合 C++ 编程思想，而且极容易出错。</p><p>2、在确定对象无需共享的情况下，使用 boost::scoped_ptr（当然动态数组使用 boost::scoped_array）。</p><p>3、在对象需要共享的情况下，使用 boost::shared_ptr（当然动态数组使用 boost::shared_array）。</p><p>4、在需要访问 boost::shared_ptr 对象，而又不想改变其引用计数的情况下，使用 boost::weak_ptr，一般常用于软件框架设计中。</p><p>5、最后一点，也是要求最苛刻一点：在你的代码中，不要出现 delete 关键字（或 C 语言的 free 函数），因为可以用智能指针去管理。</p><h5 id="感谢各位大佬们的干货："><a href="#感谢各位大佬们的干货：" class="headerlink" title="感谢各位大佬们的干货："></a>感谢各位大佬们的干货：</h5><p><a href="https://blog.csdn.net/zy19940906/article/details/50470087" target="_blank" rel="noopener">c++11智能指针解析——揭开底层面纱，完整理解智能指针</a></p><p><a href="https://my.oschina.net/hevakelcj/blog/465978" target="_blank" rel="noopener">C++11中的智能指针</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;介绍三个智能指针：unique_ptr、shared_ptr、weak_ptr。auto_ptr已经被C++11丢弃了。&lt;/li&gt;
&lt;li&gt;C++的内存管理中，当我们写一个new语句时，一般立即跟一个delete，但是也很难保证没有运行到delete就返回了。申请的资源没有释放，就会造成内存泄露，所以就有了智能指针。
    
    </summary>
    
      <category term="编程之美" scheme="http://askunix.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="智能指针" scheme="http://askunix.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="底层原理" scheme="http://askunix.github.io/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【回炉重造】C++虚函数和纯虚函数</title>
    <link href="http://askunix.github.io/2018/08/03/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://askunix.github.io/2018/08/03/虚函数与纯虚函数/</id>
    <published>2018-08-03T15:38:51.000Z</published>
    <updated>2018-08-03T08:06:13.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>C++中的虚函数的作用主要是实现了多态的机制。</li><li>多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用相同的代码来实现可变的算法。<a id="more"></a></li></ul><hr><center><font size="6">C++虚函数</font> </center><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>用virtual关键字修饰的函数就叫虚函数。</p><p>虚函数实现机制：</p><p>C++编译阶段，没办法知道一个基类的指针或引用所指对象的类型，所以没办法通过这个指针判断调用的虚函数到底是谁的，所以只能通过查找虚函数表来找到函数的入口地址。</p><p>一个类，如果有虚函数，那么编译器在编译这个类的时候就会为它添加一个虚函数表，以及指向这个虚函数表的指针。继承这个基类的之类，也会新建一个虚函数表，如果没有重载，那么这个新的虚函数表中的函数指针就被拷贝为父类该函数的地址，否则为新的函数地址。编译器会将这些函数指针在虚函数表中按照基类中该函数出现的次序排列，子类中的虚函数表也将以这种方式排列。</p><p>每个有虚函数的类都有一个虚函数表指针pv，当通过指针或引用调用一个虚函数时，先通过pv找到虚函数表，然后根据这个虚函数在虚函数表中的偏移量来找到正确的函数地址，然后再CALL之。</p><h4 id="虚函数举例说明"><a href="#虚函数举例说明" class="headerlink" title="虚函数举例说明"></a>虚函数举例说明</h4><p>虚函数表是在类之外的，一个类的size不包括虚函数表的大小。而虚函数指针则包含在类中，sizeof一个类则会包含一个虚函数表的指针。</p><ul><li>测试虚函数表指针：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> _base;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base b;</span><br><span class="line">b._base = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(b) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 输出 8（64位VS2013环境）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象 b 的大小为什么为 8 字节？</p><p>另外4个字节存放了一个void**类型的指针_vfptr，该指针就是虚表指针<br>虚表指针指向虚函数表，该表存放的就是类Base中的虚函数的地址。</p><ul><li>多继承模式下的对象模型：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base1::f1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> _base1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base2::f1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> _base2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f1()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f2()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> _derived;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/333333333333333333.jpg" alt="这里写图片描述"></p><hr><center><font size="6">纯虚函数</font> </center><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>纯虚函数的定义：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span><span class="comment">//虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;....&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  <span class="keyword">double</span> <span class="title">calcPerimeter</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”。</p><h4 id="为什么要引入虚函数"><a href="#为什么要引入虚函数" class="headerlink" title="为什么要引入虚函数"></a>为什么要引入虚函数</h4><p>1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。</p><p>2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。</p><p>3、为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。</p><p>4、声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。</p><p>纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。</p><p>5、定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。<br>纯虚函数的意义：让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。</p><h4 id="纯虚函数的实现原理："><a href="#纯虚函数的实现原理：" class="headerlink" title="纯虚函数的实现原理："></a>纯虚函数的实现原理：</h4><p> 在虚函数原理的基础上，虚函数表中，虚函数的地址是一个有意义的值，如果是纯虚函数就实实在在的写一个0。</p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li>含有纯虚函数的类被称为抽象类</li></ul><p>含有纯虚函数的类被称为抽象类，比如上面代码中的类就是一个抽象类，包含一个计算周长的纯虚函数。哪怕只有一个纯虚函数，那么这个类也是一个抽象类，纯虚函数没有函数体，所以抽象类不允许实例化对象，抽象类的子类也可以是一个抽象类。抽象类子类只有把抽象类当中的所有的纯虚函数都做了实现才可以实例化对象。</p><p>对于抽象的类来说，我们往往不希望它能实例化，因为实例化之后也没什么用，而对于一些具体的类来说，我们要求必须实现那些要求（纯虚函数），使之成为有具体动作的类。</p><h4 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h4><ul><li>仅含有纯虚函数的类称为接口类</li></ul><p>如果在抽象类当中仅含有纯虚函数而不含其他任何东西，我们称之为接口类。</p><blockquote><p>1、没有任何数据成员<br>2、仅有成员函数<br>3、成员函数都是纯虚函数</p></blockquote><ul><li>接口类理解：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span>//会飞</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//起飞</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>=<span class="number">0</span>;<span class="comment">//降落</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span><span class="keyword">public</span> Flyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">takeoff</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">land</span><span class="params">()</span></span>&#123;....&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flyMatch</span><span class="params">(Flyable *a,Flyable *b)</span><span class="comment">//飞行比赛</span></span></span><br><span class="line"><span class="function"><span class="comment">//要求传入一个会飞对象的指针，此时鸟类的对象指针可以传入进来</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    a-&gt;takeoff();</span><br><span class="line">    b-&gt;takeoff();</span><br><span class="line">    a-&gt;land();</span><br><span class="line">    b-&gt;land();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，定义一个会飞的接口，凡是实现这个接口的都是会飞的，飞行比赛要求会飞的来参加，鸟实现了会飞的接口，所以鸟可以参加飞行比赛，如果复杂点定义一个能够射击的接口，那么实现射击接口的类就可以参加战争之类需要会射击的对象，有一个战斗机类通过多继承实现会飞的接口和射击的接口还可以参加空中作战。</p><hr><center><font size="6">一些重要的问题</font> </center><h4 id="问题一：多态中存在的内存泄露"><a href="#问题一：多态中存在的内存泄露" class="headerlink" title="问题一：多态中存在的内存泄露"></a>问题一：多态中存在的内存泄露</h4><p>如果在圆形的类中定义一个圆心的坐标，并且坐标是在堆中申请的内存，则在mian函数中通过父类指针操作子类对象的成员函数的时候是没有问题的，可是在销毁对象内存的时候则只是执行了父类的析构函数，子类的析构函数却没有执行，这会导致内存泄漏。部分代码如下(想去借助父类指针去销毁子类对象的时候去不能去销毁子类对象)</p><p>如果delete后边跟父类的指针则只会执行父类的析构函数，如果delete后面跟的是子类的指针，那么它即会执行子类的析构函数，也会执行父类的析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> r);</span><br><span class="line">    ~Circle();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> m_dR;</span><br><span class="line">    Coordinate *m_pCenter;      <span class="comment">//坐标类指针</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line">Circle::Circle(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> r)</span><br><span class="line">&#123;</span><br><span class="line">    m_pCenter=<span class="keyword">new</span> Coordinate(x,y);</span><br><span class="line">    m_dR=r;</span><br><span class="line">&#125;</span><br><span class="line">Circle::~Circle()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> m_pCenter;</span><br><span class="line">    m_pCenter-<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape *shape1=<span class="keyword">new</span> Circle(<span class="number">3</span>,<span class="number">5</span>,<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();</span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须要去解决这个问题，不解决这个问题当使用的时候都会造成内存泄漏。面对这种情况则需要引入虚析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>:</span><span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Circle();<span class="comment">//与虚函数相同，此处virtual可以不写，系统将会自动添加，建议写上</span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这样父类指针指向的是哪个对象，哪个对象的构造函数就会先执行，然后执行父类的构造函数。销毁的时候子类的析构函数也会执行。</p><p>virtual关键字可以修饰普通的成员函数，也可以修饰析构函数，但并不是没有限制。</p><p>virtual在函数中的使用限制：</p><ul><li><p>1、普通函数不能是虚函数，也就是说这个函数必须是某一个类的成员函数，不可以是一个全局函数，否则会导致编译错误。</p></li><li><p>2、静态成员函数不能是虚函数 static成员函数是和类同生共处的，他不属于任何对象，使用virtual也将导致错误。</p></li><li><p>3、内联函数不能是虚函数 如果修饰内联函数 如果内联函数被virtual修饰，计算机会忽略inline使它变成存粹的虚函数。</p></li><li><p>4、构造函数不能是虚函数，否则会出现编译错误。</p></li></ul><h4 id="问题二：多态的实现原理"><a href="#问题二：多态的实现原理" class="headerlink" title="问题二：多态的实现原理"></a>问题二：多态的实现原理</h4><p>   虚函数表指针：类中除了定义的函数成员，还有一个成员是虚函数表指针（占四个基本内存单元），这个指针指向一个虚函数表的起始位置，这个表会与类的定义同时出现，这个表存放着该类的虚函数指针，调用的时候可以找到该类的虚函数表指针，通过虚函数表指针找到虚函数表，通过虚函数表的偏移找到函数的入口地址，从而找到要使用的虚函数。</p><p>  当实例化一个该类的子类对象的时候，（如果）该类的子类并没有定义虚函数，但是却从父类中继承了虚函数，所以在实例化该类子类对象的时候也会产生一个虚函数表，这个虚函数表是子类的虚函数表，但是记录的子类的虚函数地址却是与父类的是一样的。所以通过子类对象的虚函数表指针找到自己的虚函数表，在自己的虚函数表找到的要执行的函数指针也是父类的相应函数入口的地址。</p><p>如果我们在子类中定义了从父类继承来的虚函数，对于父类来说情况是不变的，对于子类来说它的虚函数表与之前的虚函数表是一样的，但是此时子类定义了自己的（从父类那继承来的）相应函数，所以它的虚函数表当中管于这个函数的指针就会覆盖掉原有的指向父类函数的指针的值，换句话说就是指向了自己定义的相应函数，这样如果用父类的指针，指向子类的对象，就会通过子类对象当中的虚函数表指针找到子类的虚函数表，从而通过子类的虚函数表找到子类的相应虚函数地址，而此时的地址已经是该函数自己定义的虚函数入口地址，而不是父类的相应虚函数入口地址，所以执行的将会是子类当中的虚函数。这就是多态的原理。</p><h4 id="问题三：函数的覆盖和隐藏"><a href="#问题三：函数的覆盖和隐藏" class="headerlink" title="问题三：函数的覆盖和隐藏"></a>问题三：函数的覆盖和隐藏</h4><ul><li>父类和子类出现同名函数称为隐藏。</li></ul><p>父类对象.函数名(…);     //调用父类的函数<br>子类对象.函数名(…);           //调用子类的函数<br>子类对象.父类名::函数名(…);//子类调用从父类继承来的函数。</p><ul><li>父类和子类出现同名虚函数称为覆盖</li></ul><p>父类指针=new 子类名(…);</p><p>父类指针-&gt;函数名(…);//调用子类的虚函数。</p><h4 id="问题四：虚析构函数的实现原理"><a href="#问题四：虚析构函数的实现原理" class="headerlink" title="问题四：虚析构函数的实现原理"></a>问题四：虚析构函数的实现原理</h4><ul><li>虚析构函数的特点：</li></ul><p>当我们在父类中通过virtual修饰析构函数之后，通过父类指针指向子类对象，通过delete接父类指针就可以释放掉子类对象。</p><ul><li>理论前提：</li></ul><p>执行完子类的析构函数就会执行父类的析构函数</p><ul><li>原理：</li></ul><p>如果父类当中定义了虚析构函数，那么父类的虚函数表当中就会有一个父类的虚析构函数的入口指针，指向的是父类的虚析构函数，子类虚函数表当中也会产生一个子类的虚析构函数的入口指针，指向的是子类的虚析构函数，这个时候使用父类的指针指向子类的对象，delete接父类指针，就会通过指向的子类的对象找到子类的虚函数表指针，从而找到虚函数表，再虚函数表中找到子类的虚析构函数，从而使得子类的析构函数得以执行，子类的析构函数执行之后系统会自动执行父类的虚析构函数。这个是虚析构函数的实现原理。</p><h4 id="问题五：设计一个不能被继承的类"><a href="#问题五：设计一个不能被继承的类" class="headerlink" title="问题五：设计一个不能被继承的类"></a>问题五：设计一个不能被继承的类</h4><p>类的构造函数会自动调用父类的构造函数。同样，子类的析构函数也会自动调用父类的析构函数。要想一个类不能被继承，我们只要把它的构造函数和析构函数都定义为私有函数。那么当一个类试图从它那继承的时候，必然会由于试图调用构造函数、析构函数而导致编译错误。</p><h4 id="问题六：C语言模拟实现C-的继承与多态"><a href="#问题六：C语言模拟实现C-的继承与多态" class="headerlink" title="问题六：C语言模拟实现C++的继承与多态"></a>问题六：C语言模拟实现C++的继承与多态</h4><h6 id="一、面向过程编程与面向对象编程的区别"><a href="#一、面向过程编程与面向对象编程的区别" class="headerlink" title="一、面向过程编程与面向对象编程的区别"></a>一、面向过程编程与面向对象编程的区别</h6><p>C语言是一种典型的面向过程编程语言，而C++确实在它的基础上改进的一款面向对象编程语言，那么，面向过程与面向对象到底有什么样的区别呢？</p><p>【从设计方法角度看】<br>面向过程程序设计方法采用函数（或过程）来描述对数据的操作，但又将函数与其操作的数据分离开来。<br>面向对象程序设计方法是将数据和对象的操作封装在一起，作为一个整体来处理。</p><p>【从维护角度看】<br>面向过程程序设计以过程为中心，难于维护。<br>面向对象程序设计以数据为中心，数据相对功能而言，有较强的稳定性，因此更易于维护。</p><h6 id="二、继承与多态的概念"><a href="#二、继承与多态的概念" class="headerlink" title="二、继承与多态的概念"></a>二、继承与多态的概念</h6><p>继承：是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性<br>和行为，并能扩展新的能力，已有类被称为父类/基类，新增加的类被称作子类/派生类。</p><p>多态：按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同现方式即为多态。同一操作作<br>用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单说就是允许基类的<br>指针指向子类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中的继承与多态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>    <span class="comment">//C++中的多态:通过虚函数实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"A:fun()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>:</span><span class="keyword">public</span> A         <span class="comment">//C++中的继承:B类公有继承A类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span>    <span class="comment">//C++中的多态:通过虚函数实现（子类的关键字virtual可加可不加）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B:fun()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言模拟C++的继承与多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*FUN)</span><span class="params">()</span></span>;      <span class="comment">//定义一个函数指针来实现对成员函数的继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">A</span>       //父类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    FUN _fun;   <span class="comment">//由于C语言中结构体不能包含函数，故只能用函数指针在外面实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">B</span>         //子类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _A _a_;     <span class="comment">//在子类中定义一个基类的对象即可实现对父类的继承</span></span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _fA()       <span class="comment">//父类的同名函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"_A:_fun()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> _fB()       <span class="comment">//子类的同名函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"_B:_fun()\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//测试C++中的继承与多态</span></span><br><span class="line">    A a;    <span class="comment">//定义一个父类对象a</span></span><br><span class="line">    B b;    <span class="comment">//定义一个子类对象b</span></span><br><span class="line"></span><br><span class="line">    A* p1 = &amp;a;   <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line">    p1-&gt;fun();    <span class="comment">//调用父类的同名函数</span></span><br><span class="line">    p1 = &amp;b;      <span class="comment">//让父类指针指向子类的对象</span></span><br><span class="line">    p1-&gt;fun();    <span class="comment">//调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//C语言模拟继承与多态的测试</span></span><br><span class="line">    _A _a;    <span class="comment">//定义一个父类对象_a</span></span><br><span class="line">    _B _b;    <span class="comment">//定义一个子类对象_b</span></span><br><span class="line">    _a._fun = _fA;        <span class="comment">//父类的对象调用父类的同名函数</span></span><br><span class="line">    _b._a_._fun = _fB;    <span class="comment">//子类的对象调用子类的同名函数</span></span><br><span class="line"></span><br><span class="line">    _A* p2 = &amp;_a;   <span class="comment">//定义一个父类指针指向父类的对象</span></span><br><span class="line">    p2-&gt;_fun();     <span class="comment">//调用父类的同名函数</span></span><br><span class="line">    p2 = (_A*)&amp;_b;  <span class="comment">//让父类指针指向子类的对象,由于类型不匹配所以要进行强转</span></span><br><span class="line">    p2-&gt;_fun();     <span class="comment">//调用子类的同名函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C++中的虚函数的作用主要是实现了多态的机制。&lt;/li&gt;
&lt;li&gt;多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用相同的代码来实现可变的算法。
    
    </summary>
    
      <category term="编程之美" scheme="http://askunix.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="虚函数" scheme="http://askunix.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
      <category term="纯虚函数" scheme="http://askunix.github.io/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Linux基础命令】你用过哪些Linux常见命令？</title>
    <link href="http://askunix.github.io/2018/08/02/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://askunix.github.io/2018/08/02/Linux基础命令总结/</id>
    <published>2018-08-02T08:42:54.000Z</published>
    <updated>2018-08-02T15:34:59.686Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h4><ul><li>① 文件目录操作类的命令，比如：cd、ls、cp、rm、find、grep、zip、tar、yum、less。</li><li>② 系统权限操作命令，比如：chmod 、chown 、sudo等。</li><li>③ 操作系统级命令，比如：shutdown、uname 、top、du、df、losf、netstat等。<a id="more"></a></li></ul><h4 id="文件目录操作类的命令："><a href="#文件目录操作类的命令：" class="headerlink" title="文件目录操作类的命令："></a>文件目录操作类的命令：</h4><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><p>（1）cd /home 进入 ‘/ home’ 目录’</p><p>（2）cd .. 返回上一级目录</p><p>（3）cd ../.. 返回上两级目录</p><p>（4）cd ~user1 进入个人的主目录</p><p>（5）cd - 返回上次所在的目录</p><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>（1）ls 查看目录中的文件</p><p>（2）ls -F 查看目录中的文件</p><p>（3）ls -l 显示文件和目录的详细资料</p><p>（4）ls -a 显示隐藏文件</p><p>（5）ls <em>[0-9]</em> 显示包含数字的文件名和目录名</p><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>（1）cp file1 file2 复制一个文件</p><p>（2）cp dir/* . 复制一个目录下的所有文件到当前工作目录</p><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>（1）rm -f file1 删除一个叫做 ‘file1’ 的文件’</p><p>（2）rmdir dir1 删除一个叫做 ‘dir1’ 的目录’</p><p>（3）rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</p><p>（4）rm -rf dir1 dir2 同时删除两个目录及它们的内容</p><h5 id="find、grep"><a href="#find、grep" class="headerlink" title="find、grep"></a>find、grep</h5><p>这两个命令我早其他博客总结过：<strong><a href="https://blog.csdn.net/m0_37925202/article/details/81359154" target="_blank" rel="noopener">Linux下的查找（grep &amp; find）</a></strong></p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>（1）zip file1.zip file1 创建一个zip格式的压缩包</p><p>（2）zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包</p><p>（3）unzip file1.zip 解压一个zip格式压缩包</p><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><p>（1）tar -cvf archive.tar file1 创建一个非压缩的 tarball</p><p>（2）tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</p><p>（3）tar -tf archive.tar 显示一个包中的内容</p><p>（4）tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下</p><p>（5）tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包</p><p>（6）tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包</p><h5 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h5><p>（1）yum install package_name 下载并安装一个rpm包</p><p>（2）yum list 列出当前系统中安装的所有包</p><p>（3）yum update package_name 更新一个rpm包</p><p>（4）yum remove package_name 删除一个rpm包</p><p>（5）yum update package_name.rpm 更新当前系统中所有安装的rpm包</p><h5 id="less"><a href="#less" class="headerlink" title="less"></a>less</h5><p>（1）less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</p><p>（2）head -2 file1 查看一个文件的前两行</p><p>（3）tail -2 file1 查看一个文件的最后两行</p><p>（4）cat file1 从第一个字节开始正向查看文件的内容</p><p>（5）tac file1 从最后一行开始反向查看一个文件的内容</p><p>（6）more file1 查看一个长文件的内容</p><h4 id="统权限操作命令"><a href="#统权限操作命令" class="headerlink" title="统权限操作命令"></a>统权限操作命令</h4><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><blockquote><p>改变文件权限命令</p></blockquote><p>（1）Chmod u+w filename  表示给文件所有者添加写权限</p><p>（2）Chmod u-w filename 表示删除文件所有者的写权限</p><p>（3）Chmod u=rwx filename 表示设置文件所有者的权限为可读，可写，可执行</p><p>（4）chmod u+x,g+w,o+w test.txt 给所有者添加执行的权限，给所有组和其它人添加写权限</p><h5 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h5><blockquote><p>改变文件拥有者：chown命令</p></blockquote><p>（1）chown user1 test.txt  比如要修改文件test.txt的拥有者为user1</p><p>（2）chown :user1 test.txt  要修改文件test.txt的拥有组为user1</p><p>（3）chown user1:user1 test.txt 要同时修改拥有者和拥有组</p><h5 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h5><blockquote><p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。<br>使用权限：在 /etc/sudoers 中有出现的使用者。</p></blockquote><p>（1）-V 显示版本编号</p><p>（2）-h 会显示版本编号及指令的使用方式说明</p><p>（3）-l 显示出自己（执行 sudo 的使用者）的权限</p><h4 id="操作系统级命令"><a href="#操作系统级命令" class="headerlink" title="操作系统级命令"></a>操作系统级命令</h4><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>（1）*shutdown -h now 关闭系统</p><p>（2）shutdown -c 取消按预定时间关闭系统</p><p>（3）shutdown -r now 重启</p><p>（4）reboot 重启</p><p>（5）logout 注销</p><h5 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h5><p>（1）uname -m 显示机器的处理器架构</p><p>（2）uname -r 显示正在使用的内核版本</p><h5 id="top"><a href="#top" class="headerlink" title="top"></a>top</h5><p>这两个命令我早其他博客总结过：<strong><a href="https://blog.csdn.net/m0_37925202/article/details/78538760" target="_blank" rel="noopener">Linux基础命令（三）之top详解</a></strong></p><h5 id="du、-df"><a href="#du、-df" class="headerlink" title="du、 df"></a>du、 df</h5><p>博客总结过：<strong><a href="https://blog.csdn.net/m0_37925202/article/details/78516416" target="_blank" rel="noopener">Linux基础命令（二）之du、df详解</a></strong></p><h5 id="losf"><a href="#losf" class="headerlink" title="losf"></a>losf</h5><p>（1）losf -i:（端口号）</p><blockquote><p>losf -i:8080  → 查看这个端口号有哪些进程在访问</p></blockquote><h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><p>（1）netstat -a ：列出所有端口（包括监听和未监听的）</p><p>（2）netstat -l ：列出所有处于监听状态的socket（只显示监听端口）</p><p>（3）netstat -t：仅显示TCP相关选项</p><p>（4）netstat -u：仅显示UDP相关选项</p><p>（5）netstat -r：显示路由信息，路由表</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;① 文件目录操作类的命令，比如：cd、ls、cp、rm、find、grep、zip、tar、yum、less。&lt;/li&gt;
&lt;li&gt;② 系统权限操作命令，比如：chmod 、chown 、sudo等。&lt;/li&gt;
&lt;li&gt;③ 操作系统级命令，比如：shutdown、uname 、top、du、df、losf、netstat等。
    
    </summary>
    
      <category term="工具操作" scheme="http://askunix.github.io/categories/%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Linux命令" scheme="http://askunix.github.io/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Centos下命令" scheme="http://askunix.github.io/tags/Centos%E4%B8%8B%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>成长是从认识自己的无知开始的</title>
    <link href="http://askunix.github.io/2018/08/02/%E6%88%90%E9%95%BF%E6%98%AF%E4%BB%8E%E8%AE%A4%E8%AF%86%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%A0%E7%9F%A5%E5%BC%80%E5%A7%8B%E7%9A%84/"/>
    <id>http://askunix.github.io/2018/08/02/成长是从认识自己的无知开始的/</id>
    <published>2018-08-01T17:14:30.000Z</published>
    <updated>2018-08-02T14:20:14.264Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>毒鸡汤奉上。</li><li>操作环境：Vim编辑器。<a id="more"></a></li></ul><p>敬请期待</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;毒鸡汤奉上。&lt;/li&gt;
&lt;li&gt;操作环境：Vim编辑器。
    
    </summary>
    
      <category term="程序人生" scheme="http://askunix.github.io/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="随笔" scheme="http://askunix.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>【排序算法】快速排序（可视化描述，三种方法实现，四种方法优化）</title>
    <link href="http://askunix.github.io/2018/07/29/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://askunix.github.io/2018/07/29/快速排序/</id>
    <published>2018-07-29T15:39:09.000Z</published>
    <updated>2018-08-03T08:04:47.047Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>这篇文章通过动态图的描述详细介绍了快速排序的原理与过程。</li><li>代码实现用三种思想完成（分治思想）。</li><li>文章中包含了四种优化方式以及实现原理（包括多线程优化）。<a id="more"></a></li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/%E5%BF%AB%E6%8B%8D%E7%AE%97%E6%B3%95.gif" alt="这里写图片描述"></p><p>该方法的基本思想是：</p><p>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”；</p><p>(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大；</p><p>(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><ul><li>总结起来就是：挖坑思想 + 分治思想</li></ul><p>对于分治思想，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>第一种方法就是直接选择这个数组的第一个元素或者最后一个元素作为基准进行排序。这种方法也是基本的快排做法，存在效率问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivot</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"><span class="comment">//low第一个元素，high最后一个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr[low];<span class="comment">//选择选取序列的第一个元素作为基准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这个数组有序，那么每次只能使这个序列 -1，就会沦为冒泡排序，时间复杂度变成O(N^2)。</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>随机选择一个基准。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*随机选择枢轴的位置，区间在low和high之间*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotRandom</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//产生基准的位置</span></span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> pivotPos = rand()%(high - low) + low;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把基准位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数</span></span><br><span class="line">swap(arr[pivotPos],arr[low]);</span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于基准的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。</p><p>但是数据相等的概率比较小，所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。“随机化快速排序可以满足一个人一辈子的人品需求”。</p><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>三数取中：效率最高的情况就是这个基准能将数组序列划分成等长度的两部分，但是这个数很难找出来，还容易拖慢快排速度。</p><p>这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准。</p><blockquote><p>给定待排序序列为：8 1 4 9 6 3 5 2 7 0</p><p>左边为：8，右边为0，中间为6。</p><p>三个数排序后，中间那个数作为基准，则基准为6。</p></blockquote><p>具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为基准，并用0下标元素存储该基准。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SelectPivotMedianOfThree</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">     <span class="comment">//三数取中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);<span class="comment">//计算数组中间的元素的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用三数取中法选择枢轴</span></span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[high]) <span class="comment">//目标: arr[mid] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[low] &gt; arr[high]) <span class="comment">//目标: arr[low] &lt;= arr[high]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[low],arr[high]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[low]) <span class="comment">//目标: arr[low] &gt;= arr[mid]</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[mid],arr[low]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此时，arr[mid] &lt;= arr[low] &lt;= arr[high]</span></span><br><span class="line"><span class="keyword">return</span> arr[low];</span><br><span class="line"><span class="comment">//low的位置上保存这三个位置中间的值</span></span><br><span class="line"><span class="comment">//分割时可以直接使用low位置的元素作为基准，而不用改变分割函数了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试方法：</p><p>1、随机生成100万个数据对函数进行性能测试；</p><p>2、生成100万个相等数据，测试函数性能；</p><p>3、生成100万个有序数据，测试函数性能。</p><h3 id="优化一："><a href="#优化一：" class="headerlink" title="优化一："></a>优化一：</h3><p>对于很小或者部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。</p><p>截止范围：待排序序列长度N = 10，（在5 - 20之间可能都会存在这样的效率问题）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//else时，正常执行快排</span></span><br></pre></td></tr></table></figure><h3 id="优化二："><a href="#优化二：" class="headerlink" title="优化二："></a>优化二：</h3><p>在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。</p><blockquote><p>待排序序列 1 4 6 7 6 6 7 6 8 6</p><p>三数取中选取基准：基准key = 6</p><p>本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6</p><p>下次的两个子序列为：1 4 6 和 7 6 7 6 8 6</p><p>本次划分后，对与key元素相等处理的结果：1 4 6 6 6 6 6 7 8 7</p><p>下次的两个子序列为：1 4 和 7 8 7</p></blockquote><p>在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少。</p><ul><li>具体思想：</li></ul><p>第一步，在划分过程中，把与key相等元素放入数组的两端</p><p>第二步，划分结束后，把与key相等的元素移到枢轴周围</p><p>变态代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> first = low;</span><br><span class="line"><span class="keyword">int</span> last = high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = low;</span><br><span class="line"><span class="keyword">int</span> right = high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> rightLen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次分割</span></span><br><span class="line"><span class="keyword">int</span> key = SelectPivotMedianOfThree(arr,low,high);<span class="comment">//使用三数取中法选择基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(high &gt; low &amp;&amp; arr[high] &gt;= key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[high] == key)<span class="comment">//处理相等元素</span></span><br><span class="line">&#123;</span><br><span class="line">swap(arr[right],arr[high]);</span><br><span class="line">right--;</span><br><span class="line">rightLen++;</span><br><span class="line">&#125;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[low] = arr[high];</span><br><span class="line"><span class="keyword">while</span>(high &gt; low &amp;&amp; arr[low] &lt;= key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[low] == key)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[left],arr[low]);</span><br><span class="line">left++;</span><br><span class="line">leftLen++;</span><br><span class="line">&#125;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">arr[high] = arr[low];</span><br><span class="line">&#125;</span><br><span class="line">arr[low] = key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次快排结束</span></span><br><span class="line"><span class="comment">//把与枢轴key相同的元素移到枢轴最终位置周围</span></span><br><span class="line"><span class="keyword">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = first;</span><br><span class="line"><span class="keyword">while</span>(j &lt; left &amp;&amp; arr[i] != key)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[i],arr[j]);</span><br><span class="line">i--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">i = low + <span class="number">1</span>;</span><br><span class="line">j = last;</span><br><span class="line"><span class="keyword">while</span>(j &gt; right &amp;&amp; arr[i] != key)</span><br><span class="line">&#123;</span><br><span class="line">swap(arr[i],arr[j]);</span><br><span class="line">i++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">QSort(arr,first,low - <span class="number">1</span> - leftLen);</span><br><span class="line">QSort(arr,low + <span class="number">1</span> + rightLen,last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个性能测试分析图：（大神的）</p><p><img src="http://p9ff104hp.bkt.clouddn.com/4444444444.jpg" alt=""></p><p> 测试数据分析：三数取中选择枢轴+插排+聚集相等元素的组合，效果竟然好的出奇。其实这里，插排的作用还是不怎么大的。</p><h3 id="优化三："><a href="#优化三：" class="headerlink" title="优化三："></a>优化三：</h3><p>快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。</p><p>优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivotPos = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (high - low + <span class="number">1</span> &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">InsertSort(arr,low,high);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">pivotPos = Partition(arr,low,high);</span><br><span class="line">QSort(arr,low,pivotPos<span class="number">-1</span>);</span><br><span class="line">low = pivotPos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////注意：在第一次递归后，low就没用了，此时第二次递归可以使用循环代替/////</span></span><br></pre></td></tr></table></figure><p>测试数据分析：</p><p><img src="http://p9ff104hp.bkt.clouddn.com/333333333.jpg" alt=""></p><p>测试数据分析：其实这种优化编译器会自己优化，相比不使用优化的方法，时间几乎没有减少.</p><h3 id="优化四："><a href="#优化四：" class="headerlink" title="优化四："></a>优化四：</h3><p>使用并行或多线程处理子序列。（不知道怎么实现，但可以简单理解下处理过程，以及多线程实现存在的问题。）</p><p><img src="http://p9ff104hp.bkt.clouddn.com/555555555.jpg" alt=""></p><h3 id="复杂度问题："><a href="#复杂度问题：" class="headerlink" title="复杂度问题："></a>复杂度问题：</h3><p>当划分均衡时，平均时间复杂度O(nlogn），空间O(logn）；当划分完全不均衡时，最坏时间O(n²），空间O(n）。</p><h3 id="快排为什么这么快："><a href="#快排为什么这么快：" class="headerlink" title="快排为什么这么快："></a>快排为什么这么快：</h3><p><strong>推荐阅读：<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/" target="_blank" rel="noopener">数学之美番外篇：快排为什么那样快</a></strong></p><p>总结一下就是三个原因：</p><ul><li>堆排序平均最坏时间复杂度都为O(nlogn），但为什么实际应用中快排效果好于堆排？</li></ul><p>虽然都是O(nlogn）级别，但是时间复杂度是近似得到的，快排前面的系数更小，所以性能更好些。</p><p>堆排比较交换次数更多。</p><p>第三个原因也是最主要的原因，和cpu高速缓冲存储器（cache）有关。由计算机组成原理，我们了解过，cpu有一块高速缓存区（cache）。堆排序要经常处理距离很远的数，不符合局部性原理，会导致cache命中率降低，频繁读写内存。</p><p><strong>完整代码：<a href="https://github.com/askunix/Data-Structure/blob/master/Quick_Sort.c" target="_blank" rel="noopener">点击即可查看</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;这篇文章通过动态图的描述详细介绍了快速排序的原理与过程。&lt;/li&gt;
&lt;li&gt;代码实现用三种思想完成（分治思想）。&lt;/li&gt;
&lt;li&gt;文章中包含了四种优化方式以及实现原理（包括多线程优化）。
    
    </summary>
    
      <category term="编程之美" scheme="http://askunix.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构" scheme="http://askunix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="快速排序" scheme="http://askunix.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【排序算法】直接插入排序 &amp; 折半插入排序（二分法插入排序）</title>
    <link href="http://askunix.github.io/2018/07/29/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://askunix.github.io/2018/07/29/插入排序/</id>
    <published>2018-07-29T15:38:51.000Z</published>
    <updated>2018-07-31T11:14:32.593Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>排序：就是将一组杂乱无章的数据按照一定的规律(升序或降序)组织起来。</li><li>数据表：待排序数据元素的有限集合。</li><li>排序码：通常数据元素有多个属性域，其中有一个属性域可用来区分元素，作为排序依据，该域即为排序码。<a id="more"></a></li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/%E5%93%88%E5%93%88%E5%93%88%E5%93%88.gif" alt=""></p><h5 id="排序算法的性能评估："><a href="#排序算法的性能评估：" class="headerlink" title="排序算法的性能评估："></a>排序算法的性能评估：</h5><p>一个算法执行时间是衡量算法好坏的重要参数。排序算法的时间开销可用算法中的数据交换次数，和数据移动次数来衡量。</p><hr><h2><center>直接插入排序算法</center></h2><h5 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h5><p>当插入第 i 个元素时，前面的 i-1 个元素已经有序。其实直接插入排序就是拿一个数，放到前面有序的数中就可以了。具体怎么放，不管是循环交换两个数的位置，还是先找到位置，再将该位置后面的数顺移，都没毛病的。</p><p><img src="http://p9ff104hp.bkt.clouddn.com/333333.jpg" alt="这里写图片描述"></p><p>#####算法性质：</p><ul><li>直接排序算法是稳定的，</li><li>算法的时间复杂度为O(n^2)，</li><li>最好是用于量小、接近有序的数据。</li></ul><h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INsert_Sort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">key = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">for</span> (end = i - <span class="number">1</span>; (end &gt;= <span class="number">0</span>) &amp;&amp; <span class="built_in">array</span>[end] &gt; key; end--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">array</span>[end + <span class="number">1</span>] = <span class="built_in">array</span>[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[end + <span class="number">1</span>] = key;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>刚在前面直接插入排序算法性质中说最好用于数据量小且基本有序的的情况。当数据量比较大时，时间会大量的耗费在移动和比较元素上，导致性能降低。因此可以从元素比较和移动上来优化算法。</p><h2><center>折半插入排序算法</center></h2><p>折半插入排序又称二分法插入排序。和直接插入排序算法不同的是：在插入元素时，利用折半搜索法寻找插入位置。</p><h5 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h5><p>过程同直接插入排序，仅仅是在找插入位置时，不是顺序遍历，而是二分法查找位置。因为：如果要找地 i 个元素的插入位置，那么第 i-1 个元素是已经有序的，可以用二分查找来寻找位置。</p><h5 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h5><ul><li>时间复杂度：折半插入排序仅仅是减少了比较元素的次数，约为O(nlogn)，而且该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数没有改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍然为O(n²)，但它的效果还是比直接插入排序要好。</li><li>空间复杂度：排序只需要一个位置来暂存元素，因此空间复杂度为O（1）。</li></ul><h5 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bin_Insert_Sort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Low;</span><br><span class="line"><span class="keyword">int</span> High;</span><br><span class="line"><span class="keyword">int</span> Middle;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Low = <span class="number">0</span>;</span><br><span class="line">High = i - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 求取插入位置</span></span><br><span class="line"><span class="keyword">while</span> (Low &lt;= High)</span><br><span class="line">&#123;</span><br><span class="line">Middle = (Low + High) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[Middle] &gt; a[i])</span><br><span class="line">High = Middle - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Low = Middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; High; --j)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[j], a[j + <span class="number">1</span>]);     <span class="comment">//这里也可以挨个移动元素后插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;排序：就是将一组杂乱无章的数据按照一定的规律(升序或降序)组织起来。&lt;/li&gt;
&lt;li&gt;数据表：待排序数据元素的有限集合。&lt;/li&gt;
&lt;li&gt;排序码：通常数据元素有多个属性域，其中有一个属性域可用来区分元素，作为排序依据，该域即为排序码。
    
    </summary>
    
      <category term="编程之美" scheme="http://askunix.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构" scheme="http://askunix.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="插入排序" scheme="http://askunix.github.io/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>长连接与短连接</title>
    <link href="http://askunix.github.io/2018/07/14/%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://askunix.github.io/2018/07/14/长连接与短连接/</id>
    <published>2018-07-14T03:52:32.000Z</published>
    <updated>2018-07-31T11:00:28.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>HTTP的长连接和短连接实质上是TCP的长连接和短连接。</li><li>HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。<a id="more"></a><h5 id="1、HTTP协议与TCP协议的关系？？"><a href="#1、HTTP协议与TCP协议的关系？？" class="headerlink" title="1、HTTP协议与TCP协议的关系？？"></a>1、HTTP协议与TCP协议的关系？？</h5></li></ul><p>HTTP的长连接和短连接实质上是TCP的长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。</p><p><img src="http://p9ff104hp.bkt.clouddn.com/%E9%95%BF%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5.png" alt=""></p><p>IP层：解决网络路由和寻址问题<br>TCP协议：解决如何在IP层之上可靠的传输数据报，并在另一端收到发送的包，并且顺序与发出顺序一致。TCP有可靠，面向连接特点。</p><hr><h5 id="2、如何理解HTTP协议是无状态的？？"><a href="#2、如何理解HTTP协议是无状态的？？" class="headerlink" title="2、如何理解HTTP协议是无状态的？？"></a>2、如何理解HTTP协议是无状态的？？</h5><p>无状态指的是协议对事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器网页和你之前打开它之间没有任何联系。</p><p>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接协议）。</p><hr><h5 id="3、什么是长连接、短连接？？"><a href="#3、什么是长连接、短连接？？" class="headerlink" title="3、什么是长连接、短连接？？"></a>3、什么是长连接、短连接？？</h5><p>在HTTP/1.0 中，默认使用短连接。<br>就是说：浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</p><p>如果客户端浏览器访问某个HTML或者其他类型的Web页面中包含其他Web资源的这种情况，<br>如：JavaScript文件、图像文件、CSS文件等，浏览器遇到这样的Web资源，就会建立一个会话。</p><p>从 HTTP/1.1 起，默认使用长连接，保持连接持续性。<br>一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的的网页，<br>会继续使用这一条已经建立好的连接。</p><p>Keep-Alive不会永久保持连接，它有一个保持的时间，可以在不同服务器软件中设定这个时间（Apache）。<br>要实现长连接，客户端、服务器端首先得支持。</p><p>HTTP协议长连接、短连接实质上是TCP协议的长连接、短连接。</p><h6 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h6><p>模拟一下TCP短连接的情况，Client向server发起连接请求，server接到请求，然后双方建立连接，Client向server发送消息，<br>server回应client，然后一次读写就完成了，这是双方任意一放都可以发起close请求。一般都是client发起close请求。</p><ul><li>短连接优点：</li></ul><p>管理起来简单，存在的连接都是有用的，不需要额外的控制手段。</p><h6 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h6><p>模拟TCP长连接情况：client向server发送连接请求，server接受client连接，双方建立连接，client与server完成一次读写之后，<br>他们并不会主动关闭，后续的读写操作会继续使用这个连接。</p><p>首先说一下TCP/IP上说到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户端主机是否崩溃，<br>从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一半开放的连接，而服务器又在等待来自客户端的数据，<br>保活功能就是试图在服务器端检测这种半开放的连接。</p><p>如果给定的连接在两个小时内没有任何的动作，则服务器就向客户端发送一个探测报文段，</p><p>客户端必须处于以下四种转态。</p><p>1、客户端主机依然正常运行，并从服务器可达，客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时之后将保活计时器复位。</p><p>2、客户端已经崩溃，并且关闭或者正在重启。在任何一种情况下，客户端的TCP都没有响应，那么服务器端也就不能收到探测响应。<br>并在75秒后超时，服务器共发送10个这样的探测，每个间隔75秒，如果客户端没有收到一个响应，就认为客户端主机已经关闭并终止连接。</p><p>3、客户端主机已经崩溃，但是已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</p><p>4、客户端正常运行，但服务器不可达，类似2.TCP能发现的就是没有收到的响应。</p><h5 id="短连接步骤："><a href="#短连接步骤：" class="headerlink" title="短连接步骤："></a>短连接步骤：</h5><p>建立连接–数据传输–关闭连接 ——</p><h5 id="长连接步骤："><a href="#长连接步骤：" class="headerlink" title="长连接步骤："></a>长连接步骤：</h5><p>建立连接–数据传输–（保持连接）–数据传输–数据传输–关闭连接 ——</p><hr><h5 id="4、长连接和短连接的优缺点？？"><a href="#4、长连接和短连接的优缺点？？" class="headerlink" title="4、长连接和短连接的优缺点？？"></a>4、长连接和短连接的优缺点？？</h5><p>由上可知，长连接省去了较多的TCP建立、关闭操作，减少了浪费，节约时间。对于频繁请求资源的客户来说，适合用长连接。<br>不过保活功能探测周期比较长，而且只能探测TCP连接的存活，遇到恶意连接，保活功能就有点不够用了。</p><p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p><p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p><p>长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。</p><hr><h5 id="5-什么时候用长连接，短连接？"><a href="#5-什么时候用长连接，短连接？" class="headerlink" title="5. 什么时候用长连接，短连接？"></a>5. 什么时候用长连接，短连接？</h5><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。</p><p>例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。</p><p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。</p><p>如果用长连接而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;HTTP的长连接和短连接实质上是TCP的长连接和短连接。&lt;/li&gt;
&lt;li&gt;HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。
    
    </summary>
    
      <category term="SO Kernal" scheme="http://askunix.github.io/categories/SO-Kernal/"/>
    
    
      <category term="长连接" scheme="http://askunix.github.io/tags/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="短连接" scheme="http://askunix.github.io/tags/%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>【编程之美】链表面试题汇总版</title>
    <link href="http://askunix.github.io/2018/06/21/%E3%80%90%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E7%89%88/"/>
    <id>http://askunix.github.io/2018/06/21/【编程之美】链表面试题汇总版/</id>
    <published>2018-06-21T09:49:33.000Z</published>
    <updated>2018-07-31T11:05:30.239Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>对于不带头结点的单链表操作，是在面试中经常出现的，在此对于常见链表操作进行总结.    </li><li>操作：有序链表合并、链表反转、链表排序、找倒数第K个节点、非头节点前插入data、删除非尾节点、约瑟夫环、带环链表环的大小等等.<a id="more"></a></li></ul><h4 id="function-h"><a href="#function-h" class="headerlink" title="function.h"></a><code>function.h</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __FUNCTION_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __FUNCTION_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DataType int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* _<span class="title">pNext</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Node *pNode;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">InitNodeList</span><span class="params">(pNode *pHead)</span></span>;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">BuyNewNode</span><span class="params">(DataType data)</span></span>;<span class="comment">//新建节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNodeByFrontToTail</span><span class="params">(pNode *pHead, DataType data)</span></span>;<span class="comment">//头插法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNodeProntToTail</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//正序打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserttNodeByTailToFront</span><span class="params">(pNode *pHead, DataType data)</span></span>;<span class="comment">//尾插法</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">ReceiveNodeList</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//反转链表—一般方法</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">ReceiveNodeList_DG</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//反转链表——递归实现</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">MeryTwoSortNodeChangeOneSortNode</span><span class="params">(pNode pHead1, pNode pHead2)</span></span>;<span class="comment">//合并两个有序单链表——一般方法</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">MeryTwoSortNodeChangeOneSortNode_DG</span><span class="params">(pNode pHead1, pNode pHead2)</span></span>;<span class="comment">//合并两个有序单链表——递归实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortNodeList</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//链表排序——冒泡法实现</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">SearchMIdNode</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//查找中间节点——快慢指针法</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">FindLastKNode</span><span class="params">(pNode pHead, <span class="keyword">int</span> key)</span></span>;<span class="comment">//找到倒数第K个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNotIntoKHead</span><span class="params">(pNode pos, DataType data)</span></span>;<span class="comment">// 非头结点前插入data</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">FindDataInNodeList</span><span class="params">(pNode pHead, DataType k)</span></span>;<span class="comment">//寻找链表中data为K的节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteLastKNode</span><span class="params">(pNode pHead, <span class="keyword">int</span> key)</span></span>;<span class="comment">//删除倒数第K个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNotTailNode</span><span class="params">(pNode pos)</span></span>;<span class="comment">//删除单链表的非尾结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCircleForJoseph</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//构造约瑟夫环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetJosephCircle</span><span class="params">(pNode pHead, <span class="keyword">size_t</span> K)</span></span>;<span class="comment">//单链表实现约瑟夫环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCircleForList</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//构造带环链表</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">isHaveCircle</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//判断链表是否带环</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleLength</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//求环的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">GetCircleIntoNode</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//求环的入口点</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">pFrontNode</span><span class="params">(pNode pHead)</span></span>;<span class="comment">//返回链表第一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">pTailNode</span><span class="params">(pNode pHead)</span></span>; <span class="comment">//返回链表最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNotHead</span><span class="params">(pNode pos, DataType data)</span></span>;<span class="comment">// 非头结点前插入data</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="function-c"><a href="#function-c" class="headerlink" title="function.c"></a><code>function.c</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">BuyNewNode</span><span class="params">(DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pTempNode = <span class="literal">NULL</span>;</span><br><span class="line">pTempNode = (pNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(pNode));</span><br><span class="line"><span class="keyword">if</span> (pTempNode)</span><br><span class="line">&#123;</span><br><span class="line">pTempNode-&gt;data = data;</span><br><span class="line">pTempNode-&gt;_pNext = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pTempNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNodeByFrontToTail</span><span class="params">(pNode *pHead, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pTemp = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (*pHead == <span class="literal">NULL</span>)</span><br><span class="line">*pHead = BuyNewNode(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pTemp = BuyNewNode(data);</span><br><span class="line">pTemp-&gt;_pNext = *pHead;</span><br><span class="line">*pHead = pTemp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserttNodeByTailToFront</span><span class="params">(pNode *pHead, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pTest = <span class="literal">NULL</span>;</span><br><span class="line">pNode pCur = *pHead;</span><br><span class="line"></span><br><span class="line">pTest = BuyNewNode(data);</span><br><span class="line"><span class="keyword">if</span> (*pHead == <span class="literal">NULL</span>)</span><br><span class="line">(*pHead) = pTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != pCur-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line">pCur -&gt;_pNext = pTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNodeProntToTail</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//pNode pTemp = pHead;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pHead)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pHead != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, pHead-&gt;data);</span><br><span class="line">pHead = pHead-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NULL"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">ReceiveNodeList</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pTest = pHead;</span><br><span class="line"><span class="comment">//pNode pNextNode = NULL;</span></span><br><span class="line">pNode pPre = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//pNode pReverse = NULL;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;_pNext == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pTest != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pNode pNextNode = pTest-&gt;_pNext;</span><br><span class="line">pTest-&gt;_pNext = pPre;</span><br><span class="line">pPre = pTest;</span><br><span class="line">pTest = pNextNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pPre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">ReceiveNodeList_DG</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pNewNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;_pNext == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> pHead;</span><br><span class="line"></span><br><span class="line">pNewNode = ReceiveNodeList_DG(pHead-&gt;_pNext);</span><br><span class="line"></span><br><span class="line">pHead-&gt;_pNext-&gt;_pNext = pHead;                       <span class="comment">//翻转链表的指向</span></span><br><span class="line">pHead-&gt;_pNext = <span class="literal">NULL</span>;                        <span class="comment">//记得赋值NULL，防止链表错乱</span></span><br><span class="line"><span class="keyword">return</span> pNewNode;                          <span class="comment">//新链表头永远指向的是原链表的链尾</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">MeryTwoSortNodeChangeOneSortNode</span><span class="params">(pNode pHead1, pNode pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pNewNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pTemp = <span class="literal">NULL</span>;</span><br><span class="line">pNode pNextNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Node1Len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Node2Len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pHead1-&gt;_pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">++Node1Len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pHead1-&gt;_pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">++Node2Len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Node1Len &lt; Node2Len)     <span class="comment">//长的链表为pHead1</span></span><br><span class="line">&#123;</span><br><span class="line">pTemp = pHead1;</span><br><span class="line">pHead1 = pHead2;</span><br><span class="line">pHead2 = pTemp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pHead1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHead1-&gt;data &lt; pHead2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pNextNode = pHead1;</span><br><span class="line">pHead1 = pHead1-&gt;_pNext;</span><br><span class="line">pNextNode = pNextNode-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line">pNextNode = pHead2;</span><br><span class="line">pHead2 = pHead2-&gt;_pNext;</span><br><span class="line">pNextNode = pNextNode-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> pNewNode;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNextNode = pHead1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pNewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">MeryTwoSortNodeChangeOneSortNode_DG</span><span class="params">(pNode pHead1, pNode pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pNewHead = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> pHead2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pHead2 == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> pHead1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHead1-&gt;data &gt; pHead2-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pNewHead = pHead2;</span><br><span class="line">pNewHead-&gt;_pNext = MeryTwoSortNodeChangeOneSortNode_DG( pHead1, pHead2-&gt;_pNext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pNewHead = pHead1;</span><br><span class="line">pNewHead-&gt;_pNext = MeryTwoSortNodeChangeOneSortNode_DG(pHead1-&gt;_pNext, pHead2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pNewHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSortNodeList</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pTempNode = <span class="number">0</span>;</span><br><span class="line">pNode pTail = <span class="literal">NULL</span>;</span><br><span class="line">pNode pPreCur = <span class="literal">NULL</span>;</span><br><span class="line">pNode pCur = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> isFlag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;_pNext == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pHead != pTail)</span><br><span class="line">&#123;</span><br><span class="line">isFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pPreCur = pHead;</span><br><span class="line">pCur = pHead-&gt;_pNext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pCur != pTail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;data &lt; pPreCur-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">pTempNode = pCur-&gt;data;</span><br><span class="line">pCur-&gt;data = pPreCur-&gt;data;</span><br><span class="line">pPreCur-&gt;data = pTempNode;</span><br><span class="line"></span><br><span class="line">isFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pPreCur = pCur;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isFlag)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">pTail = pPreCur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">SearchMIdNode</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pFast = pHead;</span><br><span class="line">pNode pSlow = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span> || pHead-&gt;_pNext == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != pFast &amp;&amp; <span class="literal">NULL</span> != pFast-&gt;_pNext)</span><br><span class="line">&#123;</span><br><span class="line">pSlow = pSlow-&gt;_pNext;</span><br><span class="line">pFast = pFast-&gt;_pNext-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pSlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">FindLastKNode</span><span class="params">(pNode pHead, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pCur = pHead;</span><br><span class="line">pNode pSlow = pHead;</span><br><span class="line">pNode pFast = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (key--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pFast == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">pFast = pFast-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pFast != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pFast = pFast-&gt;_pNext;</span><br><span class="line">pSlow = pSlow-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pSlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteLastKNode</span><span class="params">(pNode pHead, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pPosDelNode = FindLastKNode(pHead, key+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pPosDelNode == pHead)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(pPosDelNode);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pPosDelNode-&gt;_pNext = pPosDelNode-&gt;_pNext-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">FindDataInNodeList</span><span class="params">(pNode pHead, DataType k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pCur = pHead;</span><br><span class="line"><span class="keyword">while</span> (pCur != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pCur-&gt;data == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pCur;</span><br><span class="line">&#125;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">pFrontNode</span><span class="params">(pNode pHead)</span>       <span class="comment">//返回链表第一个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pPcur = pHead;</span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> pPcur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">pTailNode</span><span class="params">(pNode pHead)</span>    <span class="comment">//返回链表最后一个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pPcur = pHead;</span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (pPcur != <span class="literal">NULL</span> &amp;&amp; pPcur-&gt;_pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pPcur = pPcur-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pPcur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCircleForList</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pTemp = <span class="literal">NULL</span>;</span><br><span class="line">pTemp = FindDataInNodeList(pHead, <span class="number">9</span>);</span><br><span class="line">pTemp-&gt;_pNext = FindDataInNodeList(pHead, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">isHaveCircle</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pSlowNode = pHead;</span><br><span class="line">pNode pFastNode = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pFastNode != pSlowNode &amp;&amp; pFastNode-&gt;_pNext != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pFastNode = pFastNode-&gt;_pNext-&gt;_pNext;</span><br><span class="line">pSlowNode = pSlowNode-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pSlowNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleLength</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode MeetNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pCur = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isHaveCircle(pHead) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">MeetNode = isHaveCircle(pHead);</span><br><span class="line">pCur = MeetNode-&gt;_pNext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pCur != MeetNode)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">pNode <span class="title">GetCircleIntoNode</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pCur = pHead;</span><br><span class="line"><span class="comment">//在判断带环问题时，返回了环中快慢指针的相遇点。</span></span><br><span class="line">pNode pMeetNodeInCircle = <span class="literal">NULL</span>;</span><br><span class="line">pMeetNodeInCircle = isHaveCircle(pHead);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pCur != pMeetNodeInCircle)</span><br><span class="line">&#123;</span><br><span class="line">pCur = pCur-&gt;_pNext;</span><br><span class="line">pMeetNodeInCircle = pMeetNodeInCircle-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pMeetNodeInCircle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetCircleForJoseph</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode front = <span class="literal">NULL</span>;</span><br><span class="line">pNode tail = <span class="literal">NULL</span>;</span><br><span class="line">front = pFrontNode(pHead);</span><br><span class="line">tail = pTailNode(pHead);</span><br><span class="line"></span><br><span class="line">tail-&gt;_pNext = front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetJosephCircle</span><span class="params">(pNode pHead, <span class="keyword">size_t</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = K;</span><br><span class="line">pNode pPreNode = pHead;</span><br><span class="line">pNode pCurNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (pPreNode-&gt;_pNext != pPreNode)</span><br><span class="line">&#123;</span><br><span class="line">count = K;</span><br><span class="line"><span class="keyword">while</span> (--count)</span><br><span class="line">&#123;</span><br><span class="line">pCurNode = pPreNode;</span><br><span class="line">pPreNode = pPreNode-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pCurNode-&gt;_pNext = pPreNode-&gt;_pNext;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d 号出去-&gt; "</span>, pPreNode-&gt;data);</span><br><span class="line"><span class="comment">//free(pPreNode);</span></span><br><span class="line">pPreNode = pPreNode-&gt;_pNext;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return pPreNode;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n最后留下的人是： %d \n\n"</span>, pPreNode-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNodeListLength</span><span class="params">(pNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">pNode pCur = pHead;</span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (pCur)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNotTailNode</span><span class="params">(pNode pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pos);</span><br><span class="line">pNode pTempNode = <span class="literal">NULL</span>;</span><br><span class="line">DataType temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换节点值</span></span><br><span class="line">temp = pos-&gt;data;</span><br><span class="line">pos-&gt;data = pos-&gt;_pNext-&gt;data;</span><br><span class="line">pos-&gt;_pNext-&gt;data = temp;</span><br><span class="line"></span><br><span class="line">pTempNode = pos-&gt;_pNext;</span><br><span class="line">pos-&gt;_pNext = pTempNode-&gt;_pNext;</span><br><span class="line"><span class="comment">//free(pTempNode);</span></span><br><span class="line">pTempNode = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertNotHead</span><span class="params">(pNode pos, DataType data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pNewNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pCur = <span class="literal">NULL</span>;</span><br><span class="line">DataType pTemp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">pNewNode = BuyNewNode(data);</span><br><span class="line"><span class="keyword">if</span> (pNewNode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">pCur = pos;</span><br><span class="line">pNewNode-&gt;_pNext = pCur-&gt;_pNext;</span><br><span class="line">pCur-&gt;_pNext = pNewNode;</span><br><span class="line"></span><br><span class="line">pTemp = pCur-&gt;data;</span><br><span class="line">pCur-&gt;data = pNewNode-&gt;data;</span><br><span class="line">pNewNode-&gt;data = pTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a><code>test.c</code></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"function.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pNode pHead1 = <span class="literal">NULL</span>;</span><br><span class="line">pNode pHead2 = <span class="literal">NULL</span>;</span><br><span class="line">pNode pNewHead = <span class="literal">NULL</span>;</span><br><span class="line">pNode pHead3 = <span class="literal">NULL</span>;</span><br><span class="line">pNode pSortNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode LastKNum = <span class="number">0</span>;</span><br><span class="line">pNode pReverseNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pR = <span class="literal">NULL</span>;</span><br><span class="line">pNode pHead4 = <span class="literal">NULL</span>;</span><br><span class="line">pNode pCirclieNode = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> CircleLength = <span class="number">0</span>;</span><br><span class="line">pNode pIntoCircleNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pHead5 = <span class="literal">NULL</span>;</span><br><span class="line">pNode JueNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pHead6 = <span class="literal">NULL</span>;</span><br><span class="line">pNode pDelNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pInsertNode = <span class="literal">NULL</span>;</span><br><span class="line">pNode pH = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">9</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">8</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">6</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">5</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">2</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">PrintNodeProntToTail(pHead1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n链表的反转、还原:\n"</span>);</span><br><span class="line">pReverseNode = ReceiveNodeList(pHead1);     <span class="comment">//反转</span></span><br><span class="line">PrintNodeProntToTail(pReverseNode);</span><br><span class="line"></span><br><span class="line">pR = ReceiveNodeList_DG(pReverseNode);      <span class="comment">//反转</span></span><br><span class="line">PrintNodeProntToTail(pR);</span><br><span class="line"></span><br><span class="line">pHead1 = pR;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\npHead1: "</span>);</span><br><span class="line">PrintNodeProntToTail(pHead1);          <span class="comment">//还原pHead1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">2</span>);</span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">3</span>);</span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">4</span>);</span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">5</span>);</span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">6</span>);</span><br><span class="line">InserttNodeByTailToFront(&amp;pHead2, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pHead2: "</span>);</span><br><span class="line">PrintNodeProntToTail(pHead2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个有序链表的合并:\n"</span>);</span><br><span class="line">pNewHead = MeryTwoSortNodeChangeOneSortNode_DG(pHead1, pHead2);</span><br><span class="line">PrintNodeProntToTail(pNewHead);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建无序链表3</span></span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">9</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">4</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">5</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">7</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">4</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">0</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead3, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\npHead3: "</span>);</span><br><span class="line">PrintNodeProntToTail(pHead3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n排序好的链表3："</span>);</span><br><span class="line">BubbleSortNodeList(pHead3);</span><br><span class="line">PrintNodeProntToTail(pHead3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\npHead1中间节点：%d\n"</span>, (SearchMIdNode(pHead1)-&gt;data));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\npNewHead中间节点：%d\n"</span>, (SearchMIdNode(pNewHead)-&gt;data));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n查找倒数第K个节点: "</span>);</span><br><span class="line">LastKNum = FindLastKNode(pNewHead, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (LastKNum != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LastKNum-&gt;data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"没有找到\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n删除倒数第K个节点\n"</span>);</span><br><span class="line">DeleteLastKNode(pNewHead, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个带环链表4</span></span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">9</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">8</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">6</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">5</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">2</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">1</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">3</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">0</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n打印链表4：\n"</span>);</span><br><span class="line">PrintNodeProntToTail(pHead4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n构造带环链表\n"</span>);</span><br><span class="line">GetCircleForList(pHead4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"构造OK\n"</span>);</span><br><span class="line"></span><br><span class="line">pCirclieNode = isHaveCircle(pHead4);</span><br><span class="line"><span class="keyword">if</span> (pCirclieNode == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不带环\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"带环\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n求环的长度："</span>);</span><br><span class="line"><span class="comment">//PrintNodeProntToTail(pHead4);</span></span><br><span class="line"></span><br><span class="line">CircleLength = GetCircleLength(pHead4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, CircleLength);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n求环的入口："</span>);</span><br><span class="line">pIntoCircleNode = GetCircleIntoNode(pHead4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pIntoCircleNode-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个链表，pHead5：    头插法构造单链表</span></span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">9</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">8</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">7</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">6</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">5</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">4</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">3</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">2</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead5, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n约瑟夫环问题:\n"</span>);</span><br><span class="line"><span class="comment">//构造环</span></span><br><span class="line">GetCircleForJoseph(pHead5);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"构造OK\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PrintNodeProntToTail(pHead5);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//约瑟夫环</span></span><br><span class="line">GetJosephCircle(pHead5, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"构造链表6\n"</span>);</span><br><span class="line"></span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead6, <span class="number">6</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead6, <span class="number">5</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead6, <span class="number">4</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead6, <span class="number">3</span>);</span><br><span class="line">InsertNodeByFrontToTail(&amp;pHead6, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n删除倒数第 3 个节点后，链表为：\n"</span>);</span><br><span class="line">DeleteLastKNode(pHead6, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除非尾节点 3 :\n"</span>);</span><br><span class="line">pDelNode = FindDataInNodeList(pHead6, <span class="number">3</span>);</span><br><span class="line">DeleteNotTailNode(pDelNode);</span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n非头节点 5 前的插入:\n"</span>);</span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"></span><br><span class="line">pInsertNode = FindDataInNodeList(pHead6, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">InsertNotHead(pInsertNode, <span class="number">99</span>);</span><br><span class="line">PrintNodeProntToTail(pHead6);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于不带头结点的单链表操作，是在面试中经常出现的，在此对于常见链表操作进行总结.    &lt;/li&gt;
&lt;li&gt;操作：有序链表合并、链表反转、链表排序、找倒数第K个节点、非头节点前插入data、删除非尾节点、约瑟夫环、带环链表环的大小等等.
    
    </summary>
    
      <category term="编程之美" scheme="http://askunix.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="链表面试题" scheme="http://askunix.github.io/tags/%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="编程之美" scheme="http://askunix.github.io/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="无头单链表" scheme="http://askunix.github.io/tags/%E6%97%A0%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言版通讯录</title>
    <link href="http://askunix.github.io/2018/06/17/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%88%AC%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>http://askunix.github.io/2018/06/17/C语言实现一般通讯录/</id>
    <published>2018-06-17T07:09:27.000Z</published>
    <updated>2018-07-31T11:02:22.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>C语言通讯录可以用来存储1000个人的信息。</li><li>每个人的信息包括姓名、年龄、性别、电话、住址。</li><li>实现基本的增、删、查、改、排序、打印、清空基本功能。<a id="more"></a></li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/44.png" alt="图片加载失败"></p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h4><ul><li><p>首先我们可以分三个模块来解决这个问题，第一个模块我们需要一个头文件，这个头文件里可以包含一些相应信息，当实现文件和测试文件包含自己定义的头文件时便可以获得一些相关的信息。所以头文件里应该包括一个结构体，这个结构体里应包含姓名，性别，年龄，电话，住址。同时还可以定义一个结构体，这个结构体里包含通讯录，同时通讯录里人员的计数变量，将通讯录的地址传到别的地方便可以实现对它遍历或者其他操作。</p></li><li><p>第二个模块便是我们的测试函数，测试函数便可以实现我们的菜单打印，同时由我们接收不同的值便可以实现不同的操作，就是相应的方法的实现，这里很明显可以通过一个switch语句来控制功能选择，用do-while语句来控制重复选择的循环部分。</p></li></ul><ul><li>第三个模块便是我们的方法实现的函数，将模块2里定义的类型为通讯录的地址传到各个方法里，这样便可以实现对通讯录的操作。</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="头文件：-lt-contect-h-gt"><a href="#头文件：-lt-contect-h-gt" class="headerlink" title="头文件： &lt;contect.h&gt;"></a>头文件： <code>&lt;contect.h&gt;</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_MAX 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEL_MAX 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEX_MAX 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span>&#123; Exit, Add, Del, Search, Modify, Empty, Sort, Show&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> Name[NAME_MAX];</span><br><span class="line"><span class="keyword">int</span> Age;</span><br><span class="line"><span class="keyword">char</span> Tel[TEL_MAX];</span><br><span class="line"><span class="keyword">char</span> Sex[SEX_MAX];</span><br><span class="line"><span class="keyword">char</span> Address[<span class="number">50</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">Stu</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Contact</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Stu Con[MAX];       <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> sz;     <span class="comment">//计数</span></span><br><span class="line">&#125;Contact, *pContact;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitContact</span><span class="params">(pContact pCon)</span></span>;  <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddContact</span><span class="params">(pContact pCon)</span></span>;   <span class="comment">//新建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowContact</span><span class="params">(pContact pCon)</span></span>;  <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelContact</span><span class="params">(pContact pCon)</span></span>;   <span class="comment">//删除</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchContact</span><span class="params">(pContact pCon)</span></span>;   <span class="comment">//查找</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyContact</span><span class="params">(pContact pCon)</span></span>;    <span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyContact</span><span class="params">(pContact pCon)</span></span>;    <span class="comment">//清空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortContact</span><span class="params">(pContact pCon)</span></span>;    <span class="comment">//排序</span></span><br></pre></td></tr></table></figure><h5 id="函数实现：-contect-cpp"><a href="#函数实现：-contect-cpp" class="headerlink" title="函数实现： contect.cpp"></a>函数实现： <code>contect.cpp</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"contect.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pCon-&gt;sz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pCon-&gt;Con, <span class="number">0</span>, MAX * <span class="keyword">sizeof</span>(Stu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入联系人姓名："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入联系人年龄："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Age;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入联系人电话："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Tel;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入联系人性别："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Sex;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入联系人地址："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Address;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"═════联系人 "</span> &lt;&lt; pCon-&gt;Con[pCon-&gt;sz].Name &lt;&lt; <span class="string">" 的信息保存成功════"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pCon-&gt;sz++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╔═════════════════════════════════════════════════════════════╗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3s\t%6s\t%2s%16s%8s%20s\n"</span>,<span class="string">"║序号"</span>,<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">"电话"</span>,<span class="string">"性别"</span>,<span class="string">"地址║"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pCon-&gt;sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d\t%6s\t%2d%16s%8s%20s\n"</span>,</span><br><span class="line">i + <span class="number">1</span>,</span><br><span class="line">pCon-&gt;Con[i].Name,</span><br><span class="line">pCon-&gt;Con[i].Age,</span><br><span class="line">pCon-&gt;Con[i].Tel,</span><br><span class="line">pCon-&gt;Con[i].Sex,</span><br><span class="line">pCon-&gt;Con[i].Address);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╚═════════════════════════════════════════════════════════════╝"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"温馨提示：输出完成！！！"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindInContact</span><span class="params">(pContact pCon, <span class="keyword">char</span> *ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pCon-&gt;sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pCon-&gt;Con[i].Name,ch) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line">ShowContact(pCon);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入上面通讯录中要删除联系人的姓名："</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;ch);</span><br><span class="line"><span class="keyword">int</span> NUM = FindInContact(pCon, ch);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"通讯录中没有该联系人！！！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NUM &lt;= pCon-&gt;sz &amp;&amp; NUM != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = NUM; j &lt;= pCon-&gt;sz<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">pCon-&gt;sz--;</span><br><span class="line">pCon-&gt;Con[j] = pCon-&gt;Con[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"删除成功！！！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SearchContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输出你要查找联系人的姓名："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;ch);</span><br><span class="line"><span class="keyword">int</span> NUM = FindInContact(pCon, ch);</span><br><span class="line"><span class="keyword">if</span> (NUM != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╔═════════════════════════════════════════════════════════════╗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3s\t%6s\t%2s%16s%8s%20s\n"</span>, <span class="string">"║序号"</span>, <span class="string">"姓名"</span>, <span class="string">"年龄"</span>, <span class="string">"电话"</span>, <span class="string">"性别"</span>, <span class="string">"地址║"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d\t%6s\t%2d%16s%8s%20s\n"</span>,</span><br><span class="line">NUM + <span class="number">1</span>,</span><br><span class="line">pCon-&gt;Con[NUM].Name,</span><br><span class="line">pCon-&gt;Con[NUM].Age,</span><br><span class="line">pCon-&gt;Con[NUM].Tel,</span><br><span class="line">pCon-&gt;Con[NUM].Sex,</span><br><span class="line">pCon-&gt;Con[NUM].Address);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╚═════════════════════════════════════════════════════════════╝"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"你要找的联系人不存在\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch[NAME_MAX];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入要修改的联系人的姓名："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;ch);</span><br><span class="line"><span class="keyword">int</span> NUM = FindInContact(pCon, ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (NUM != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╔═════════════════════════════════════════════════════════════╗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3s\t%6s\t%2s%16s%8s%20s\n"</span>, <span class="string">"║序号"</span>, <span class="string">"姓名"</span>, <span class="string">"年龄"</span>, <span class="string">"电话"</span>, <span class="string">"性别"</span>, <span class="string">"地址║"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d\t%6s\t%2d%16s%8s%20s\n"</span>,</span><br><span class="line">NUM,</span><br><span class="line">pCon-&gt;Con[NUM].Name,</span><br><span class="line">pCon-&gt;Con[NUM].Age,</span><br><span class="line">pCon-&gt;Con[NUM].Tel,</span><br><span class="line">pCon-&gt;Con[NUM].Sex,</span><br><span class="line">pCon-&gt;Con[NUM].Address);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╚═════════════════════════════════════════════════════════════╝"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请把姓名修改成："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, pCon-&gt;Con[NUM].Name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请把年龄修改成："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pCon-&gt;Con[NUM].Age);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请把电话修改成："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, pCon-&gt;Con[NUM].Tel);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请把性别修改成："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, pCon-&gt;Con[NUM].Sex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请把地址修改成："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, pCon-&gt;Con[NUM].Address);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmptyContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pCon-&gt;sz = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"清空成功！！！\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortContact</span><span class="params">(pContact pCon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pCon-&gt;sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pCon-&gt;sz-i<span class="number">-1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(pCon-&gt;Con[j].Name, pCon-&gt;Con[j + <span class="number">1</span>].Name)&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Stu temp;</span><br><span class="line">temp = pCon-&gt;Con[j];</span><br><span class="line">pCon-&gt;Con[j] = pCon-&gt;Con[j + <span class="number">1</span>];</span><br><span class="line">pCon-&gt;Con[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试函数：-test-cpp"><a href="#测试函数：-test-cpp" class="headerlink" title="测试函数： test.cpp"></a>测试函数： <code>test.cpp</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"contect.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╔═══════════════════════════════════════════════════╗"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══════════════════  通讯录  ══════════════════════║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══                                             ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══           1.新建           2.删除           ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══           3.查找           4.修改           ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══           5.清空           6.排序           ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══           7.打印           0.退出           ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"║═══                                             ═══║"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"╚═══════════════════════════════════════════════════╝"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">system(<span class="string">"color c"</span>); <span class="comment">//改变背景</span></span><br><span class="line">Contact my_con;</span><br><span class="line">InitContact(&amp;my_con);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">menu();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请选择："</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Exit:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Add:</span><br><span class="line">AddContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Del:</span><br><span class="line">DelContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Search:</span><br><span class="line">SearchContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Modify:</span><br><span class="line">ModifyContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Empty:</span><br><span class="line">EmptyContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Sort:</span><br><span class="line">SortContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> Show:</span><br><span class="line">ShowContact(&amp;my_con);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"选择错误：-&gt;!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p><img src="http://p9ff104hp.bkt.clouddn.com/777777.png" alt="图片加载失败"></p><h4 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h4><p>1、改写成链表存储，不同存储结构的区别？</p><p>2、动态版通讯录、文件版通讯录设计？</p><p>3、编写大型通讯录系统，将通讯录数据存储在数据库中？</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;C语言通讯录可以用来存储1000个人的信息。&lt;/li&gt;
&lt;li&gt;每个人的信息包括姓名、年龄、性别、电话、住址。&lt;/li&gt;
&lt;li&gt;实现基本的增、删、查、改、排序、打印、清空基本功能。
    
    </summary>
    
      <category term="小项目" scheme="http://askunix.github.io/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="C语言版通讯录" scheme="http://askunix.github.io/tags/C%E8%AF%AD%E8%A8%80%E7%89%88%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    
      <category term="结构体存储通讯录" scheme="http://askunix.github.io/tags/%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%98%E5%82%A8%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>TCP建立连接和关闭连接详解（三次握手&amp;四次挥手&amp;面试问题）</title>
    <link href="http://askunix.github.io/2018/06/15/TCP%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B&amp;%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89/"/>
    <id>http://askunix.github.io/2018/06/15/TCP建立和断开连接过程（三次握手&amp;四次挥手）/</id>
    <published>2018-06-15T00:25:40.000Z</published>
    <updated>2018-07-31T13:03:21.527Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>三次握手、四次挥手问题是面试中一定会问到的，包括在《高质量C/C++编程》一书中也有类似的习题。这篇blog就TCP连接的建立和关闭过程及相关面试问题做一个详解，如有错误，望指正。</li><li>如果对TCP还不了解，可以先阅读这篇文章：      <a href="https://blog.csdn.net/m0_37925202/article/details/80899012" target="_blank" rel="noopener">TCP固定头部结构详解</a><a id="more"></a></li></ul><h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><blockquote><p>三次握手是就是TCP在建立连接时的过程。 TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。</p></blockquote><p><img src="http://p9ff104hp.bkt.clouddn.com/001.png" alt="这里写图述"></p><p>A主机运行TCP客户端程序，B主机运行TCP服务器端程序，在A主机发送SYN之前，客户端和主机都处于CLOSED状态。</p><p>B主机先创建传输控制块PCB。准备接收客户端的请求，然后服务器端进入LISTEN状态，等待客户端连接请求。</p><ul><li><strong>第一次握手</strong></li></ul><blockquote><p>TCP客户端先创建传输控制块PCB，然后向服务器B发送连接请求报文段，此时首部中的同步位SYN置位1，同时选择一个初始序号seq = x，这是TCP客户端进入SYN-SENT（同步已发送）状态。</p></blockquote><ul><li><strong>第二次握手</strong></li></ul><blockquote><p>服务器B收到A发送的连接请求报文段后，如果同意连接，则向A发送确认，<br>在确认报文段中，将ACK和SYN都置为1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y，这是TCP服务器进入SYN-RCVD（同步收到）状态。</p></blockquote><ul><li><strong>第三次握手</strong></li></ul><blockquote><p>TCP客户端收到B发送的确认后，还要向B给出确认，确认报文ACK置为1，确认号ack = y + 1，自己的序号为seq = x + 1。TCP协议规定，ACK报文段可以携带数据，如果不携带数据，则不消耗序号，则下一数据报文段的序号仍然为seq = x + 1，这时TCP已经建立连接，A进入ESTABLISHED（已建立连接状态）。当B收到A的确认后也进入ESTANLISHED状态。</p></blockquote><p>上面这种建立连接的过程称为三次握手。</p><p><code>【面试问题1】为什么A还要再发送一次确认呢？</code></p><blockquote><p>这是为了防止某些失效的连接请求报文再次传送给服务器B而导致出错。<br>失效连接报文来源？<br>假如TCP连接就是两次握手，如果说客户端A给服务器端B发送了连接请求报文段，但是报文段丢失，导致B没有收到，于是A重传连接请求，第二次的服务器端B收到了连接请求，建立了连接。数据传输完成后就释放连接。在这个过程中，客户端A共发送两次连接请求报文，一个报文丢失，另一个报文到达了B。不存在“已失效的连接报文”。</p></blockquote><blockquote><p>现在考虑另一种特诉情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p></blockquote><h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><blockquote><p>四次挥手是TCP释放连接的过程，具体过程请看下图分析。</p></blockquote><p><img src="http://p9ff104hp.bkt.clouddn.com/002.png" alt="TCP断开连接的过程"></p><p>完成数据传输后，通信的双方都可以释放连接，主机A、B先都处于ESTABLISHED状态。</p><ul><li><strong>第一次挥手</strong></li></ul><p>A的应用进程先向其TCP发送连接释放报文段，A停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的FIN置1，其序号seq = u，它等于前面已经传送过的数据的最后一个字节序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认，注意：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。</p><ul><li><strong>第二次挥手</strong></li></ul><p>B收到连接释放报文段后，立即发出确认，确认号是ask = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT（关闭等待）状态，TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP处于半关闭状态，即A已经没有数据要发送了，但B若要发送数据，A仍要接收，也就是说，从B到A的方向连接并灭有关闭。这个状态可能会持续一些时间。</p><ul><li><strong>第三次挥手</strong></li></ul><p>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接请求释放报文段。</p><p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN = 1，现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号akc = u + 1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。</p><ul><li><strong>第四次挥手</strong></li></ul><p>A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT）设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命。MSL是根据工程来设置时长的，假设为2min。因此从A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。</p><p><code>【面试问题2】为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</code></p><blockquote><p>这有两个原因：<br>第一：为了保证A发送的最后一个ACK报文段能够到达B，这个报文段有可能丢失，因而使处在LAST-WAIT的状态B收不到对方已发送的FIN-ACK报文段的确认，B会超时重传这个FIN + ACK报文段，而A就能在2MSL时间内接收到这个重传的FIN + ACK报文段，接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TINE-WAIT装态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么久无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按正常步骤进入CLOSED状态。<br>第二：防止上文提到的“已失效的连接请求报文”出现在本连接中。A发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样可以使下一个新的连接中不会出现这种旧的连接请求报文段。<br>B只要收到A发出的确认，就进入CLOSED状态，同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接，我们注意到，B结束TCP连接的时间要比A早一些。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;三次握手、四次挥手问题是面试中一定会问到的，包括在《高质量C/C++编程》一书中也有类似的习题。这篇blog就TCP连接的建立和关闭过程及相关面试问题做一个详解，如有错误，望指正。&lt;/li&gt;
&lt;li&gt;如果对TCP还不了解，可以先阅读这篇文章：      &lt;a href=&quot;https://blog.csdn.net/m0_37925202/article/details/80899012&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TCP固定头部结构详解&lt;/a&gt;
    
    </summary>
    
      <category term="SO Kernals" scheme="http://askunix.github.io/categories/SO-Kernals/"/>
    
    
      <category term="ACK机制" scheme="http://askunix.github.io/tags/ACK%E6%9C%BA%E5%88%B6/"/>
    
      <category term="TCP连接过程" scheme="http://askunix.github.io/tags/TCP%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B/"/>
    
      <category term="三次握手四次挥手" scheme="http://askunix.github.io/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>保证TCP协议的可靠传输</title>
    <link href="http://askunix.github.io/2018/05/31/TCp%E5%8D%8F%E8%AE%AE%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <id>http://askunix.github.io/2018/05/31/TCp协议可靠传输/</id>
    <published>2018-05-31T14:34:00.000Z</published>
    <updated>2018-07-31T11:01:54.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>TCP协议在网络传输中保证了其可靠性，本篇文章对TCP协议可靠传输机制做了详细介绍。</li><li>介绍：（ACK机制&amp;滑动窗口&amp;拥塞控制&amp;流量控制）。<a id="more"></a></li></ul><h4 id="回顾内容"><a href="#回顾内容" class="headerlink" title="回顾内容"></a>回顾内容</h4><blockquote><p>传输层使用的两个主要协议：TCP和UDP</p></blockquote><ul><li><strong>TCP 主要特性有特性有以下几点：</strong></li></ul><p>　　(1)面向连接，在数据传送前必须建立连接，在数据传送结束后必须释放连接。在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP。</p><p>　　(2)点对点，每一条TCP连接只能有两个端点。从socket角度来说，通信双方需要建立套接字，套接字由IP地址和端口号组成，数据到达传输层之后会被送到端口对应的应用程序。</p><p>　　(3)提供可靠交付服务。</p><p>　　(4)支持全双工通信。</p><p>　　(5)面向字节流。面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序数据看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</p><hr><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h4><p>1、确认应答（ACK）机制：</p><p>2、超时重传机制：<br>　　接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。</p><p>3、滑动窗口机制：</p><p>4、数据校验：</p><p>　　TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p><p>5、数据合理分片和排序：</p><p>　　UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片.把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报.</p><p>　　TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。</p><p>5、流量控制：<br>　　当接收方来不及处理发送方的数据，就提示发送方降低发送的速率，防止包丢失。</p><p>7、拥塞控制：<br>　　当网络拥塞时，减少数据的发送。</p><blockquote><p>上面简单的讲了TCP保证可靠传输的几个机制，下面对较难理解的面深入探究。</p></blockquote><hr><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="滑动窗口是干什么的？"><a href="#滑动窗口是干什么的？" class="headerlink" title="滑动窗口是干什么的？"></a>滑动窗口是干什么的？</h5><p>有一种机制叫做ACK确认应答【过程如图】，收到数据段，给发送一个ACK确认应答，收到ACK应答后，再发送数据段，明显会降低效率，如果数据往返时间较长时，会影响到性能。</p><p><img src="http://p9ff104hp.bkt.clouddn.com/ACK%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6.png" alt="这里写图片描述"></p><p>上面这种方式浪费效率，如果换种方式发送呢  ^_^</p><ul><li>一次发送多个数据段，统一确认后，再发送多个数据段。</li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94.png" alt="这里写图片描述"></p><blockquote><p>上面这种传送机制就是窗口机制。</p></blockquote><ul><li>窗口是什么？</li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F.png" alt="这里写图片描述"></p><p>窗口大小：就是无需等到确认应答而可以继续发送数据的最大值。（上图窗口就是4000字节，也就是四个段）</p><ul><li>传输过程：</li></ul><p>1、客户端和服务器端各自建立套接字，通过彼此的套接字进行通信；</p><p>2、服务器端绑定监听端口，然后监听，循环等待来自客户端的连接；</p><p>3、一旦收到来自客户端的连接，进行三次握手，一旦连成功就fork()一个子进程来处理和当前客户端的连接，然后父进程继续监听客户端的连接；</p><p>4、发送前面四个段，无需ACK确认应答，直接发送；</p><p>5、收到第一个ACK后，滑动窗口向后移动，发送第五个数据段，以此类推；</p><p>6、操作系统为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉；</p><p>7、一旦数据传输完毕就是放连接。</p><blockquote><p>就是说随着时间推移，滑动窗口也在推移，滑动窗口的会变化，内部缓存数据不停的更新，根据网络的拥塞情况，发送端可以调控滑动窗口的大小来控制流量 ，滑动窗口就是一个滑的过程啊~     ^<em>*  ~ ^</em>*   可能解释的有点啰嗦了</p></blockquote><p>4、窗口越大，网络吞吐量就越高。</p><blockquote><p>吞吐量就是单位时间内通过某个网络（信道、接口）的数据量。</p></blockquote><ul><li>接收窗口大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。</li></ul><hr><h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>简单来说就是接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端。</p><p><img src="http://p9ff104hp.bkt.clouddn.com/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt="这里写图片描述"></p><p>　　当窗口值为0，而接受方把窗口值恢复（比如ACK=1，ack=601，rwnd=200），但确认丢失，进入相互等待的死锁局面。所以如果窗口值为0，发送端就会开启一个持续计数器，每个一段时间询问一下接收方。</p><hr><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><ul><li>什么是拥塞？</li></ul><p>　　是指计算机网络中，某一个时段，某一资源的需求量超过了该资源可提供的可用部分，网络性能变差。</p><ul><li>什么是拥塞控制？</li></ul><p>　　所谓的拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或者节点不至于过载，拥塞控制是一个全局的过程。</p><ul><li>几种拥塞控制的方法：因特网建议标准RFC定义了几种拥塞控制的算法；</li></ul><blockquote><ul><li>满开始，拥塞避免，</li><li>快重传，快恢复。</li></ul></blockquote><ul><li><strong>拥塞控制描述：</strong></li></ul><p>　　唯一的方法就是尝试各种不同的发送速度。比如一开始以 100kb/s 的速率发送数据，如果没问题，再将速率提高到 200kb/s，再没问题继续提升发送速率。一旦达到某个上限后，便开始出现丢包现象，发送方就可以认为，网络已经拥塞了，于是降低发送速率，减轻网络负担。</p><ul><li><strong>控制流程简述：</strong></li></ul><blockquote><p><strong>慢开始、拥塞避免</strong></p></blockquote><p>　　发送方维持一个拥塞窗口的状态变量，其大小取决于网络的拥塞程度，动态地变化，而发送窗口一般取拥塞窗口和对方给出的接收窗口的最小值（为了便于描述，后面的分析中假定对方给出的接收窗口足够大，这样将发送窗口等于拥塞窗口就可以了）。</p><p>　　慢开始算法的核心是从小到大逐渐增大发送窗口，也就是说，从小到大逐渐增大拥塞窗口的数值。通常在刚开始发送报文段时，先把拥塞窗口设置为一个最大报文段MSS的数值，而在每收到对上一轮报文段（，每次加倍后的报文段的个数，可能不止一个报文段）的确认后，就把拥塞窗口的数值加倍。</p><p>　　为了防止拥塞窗口增长过大引起网络拥塞，还需要维护一个慢开始门限的状态变量，当拥塞窗口的值小于慢开始门限时，使用慢开始算法，一旦拥塞窗口的值大于慢开始门限的值，就改用拥塞避免算法。</p><p>　　拥塞避免算法的思路是让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。</p><p>　　无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有按时收到确认），就把慢开始门限设置为出现拥塞时发送窗口值的一般，但最小不能小于2个MSS值，而后把拥塞窗口的值重新设置为1个MSS，执行慢开始算法。</p><blockquote><p><strong>快重传，快恢复</strong></p></blockquote><p>　　快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（重复发送对前面有序部分的确认），而不是等待自己发送数据时才进行稍待确认，也不是累积收到的报文发送累积确认，如果发送方连续收到三个重复确认，就应该立即重传对方未收到的报文段（有收到重复确认，说明后面的报文段都送达了，只有中间丢失的报文段没送达）。</p><p>快恢复算法与快重传算法配合使用，其过程有如下两个要点：</p><p>　　1、当发送方连续收到三个重复确认时，就把慢开始门限减半，这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。</p><p>　　2、由于发送方现在认为网络很很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。</p><h4 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h4><p>1、网络拥堵是怎么来的？</p><p>2、RFC 定义的 4 种拥塞控制算法是什么？分别讲述流程以及原理？</p><p>3、为什么TCP传输这么复杂？</p><blockquote><p>因为要保证可靠传输，同时又要尽可能提高性能。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;TCP协议在网络传输中保证了其可靠性，本篇文章对TCP协议可靠传输机制做了详细介绍。&lt;/li&gt;
&lt;li&gt;介绍：（ACK机制&amp;amp;滑动窗口&amp;amp;拥塞控制&amp;amp;流量控制）。
    
    </summary>
    
      <category term="SO Kernal" scheme="http://askunix.github.io/categories/SO-Kernal/"/>
    
    
      <category term="ACK机制" scheme="http://askunix.github.io/tags/ACK%E6%9C%BA%E5%88%B6/"/>
    
      <category term="TCP协议" scheme="http://askunix.github.io/tags/TCP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="滑动窗口" scheme="http://askunix.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
      <category term="拥塞控制" scheme="http://askunix.github.io/tags/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    
      <category term="流量控制" scheme="http://askunix.github.io/tags/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>UDP协议实现服务器-客户端通信</title>
    <link href="http://askunix.github.io/2018/05/22/%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://askunix.github.io/2018/05/22/基于UDP协议的回显服务器/</id>
    <published>2018-05-21T17:14:30.000Z</published>
    <updated>2018-07-31T11:42:49.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>回显服务器的代码实现过程，文章加入了详细的设计过程以及其他的计算机网络理论知识。</li><li>操作环境：CentOS 7.0 X64 操作系统、Vim编辑器、Gcc编译器。<a id="more"></a><img src="http://p9ff104hp.bkt.clouddn.com/%E7%BD%91%E7%BB%9C.jpg" alt="图片加载失败"></li></ul><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><ul><li>本文的目的是写回显服务器，在撸代码之前，先来个热身。</li></ul><h5 id="IP地址是什么"><a href="#IP地址是什么" class="headerlink" title="IP地址是什么"></a>IP地址是什么</h5><p>IP地址有IPV4、IPV6之分，一般不特俗说明，默认就是IPV4。</p><blockquote><p>IP地址是用来标识不同的主机，每个主机都有唯一的IP地址；<br>对于IP4来说，IP地址是一个4字节，32位整数；<br>IP地址用“点分”制表示，如：192.168.1.11（用点分割的每个数范围0~255）。</p></blockquote><h5 id="源IP地址-amp-目的IP地址"><a href="#源IP地址-amp-目的IP地址" class="headerlink" title="源IP地址&amp;目的IP地址"></a>源IP地址&amp;目的IP地址</h5><blockquote><p>很容易理解，都是地址，和寄快递的收发地址一样，从上海发往西安的快递，源IP就是上海，目的IP就是西安。</p></blockquote><h5 id="端口号是什么"><a href="#端口号是什么" class="headerlink" title="端口号是什么"></a>端口号是什么</h5><ul><li>端口号是传输层协议内容</li></ul><blockquote><p>端口号是2字节196位整数；<br>端口号用来标识一个进程，告诉操作系统，当前数据要交给哪一个进程来处理；<br><strong>一个进程可以绑定多个端口号，但是一个端口号不可以绑定多个进程。</strong></p></blockquote><h5 id="源端口号-amp-目的端口号"><a href="#源端口号-amp-目的端口号" class="headerlink" title="源端口号&amp;目的端口号"></a>源端口号&amp;目的端口号</h5><blockquote><p>在源IP&amp;目的IP中，我们用的寄快递的例子帮助理解，在这里，还是用发快递帮助理解。源IP与目的IP标识了发件人地址和收件人的地址，地址有了，那么包裹就会交给快递员运送每个，快递员都有一个工号，工号是唯一的。这就对应了数据传输过程中，由哪个进程来处理数据。再来到寄快递问题上，有的快递包裹比较大，这就要多个快递员来运输，那么一个包裹由多个快递员运输，记在物流信息上就是这样的格式：一个包裹的目的地 + 多个快递员工号；这家公司接的都是大包裹，一个快递员只能送一个包裹。对应到网络传输中，就是一个进程可以绑定多个端口号，但一个端口号不可以绑定多个进程。</p></blockquote><hr><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><ul><li>为后面撸代码介绍几个函数。</li></ul><h5 id="网络字节序："><a href="#网络字节序：" class="headerlink" title="网络字节序："></a>网络字节序：</h5><p>在C语言中我们知道，内存中的数据存储有大小端之分；数据在磁盘中存储也有大小端之分，在这里我还想啰嗦一个C语言问题，怎样判断自己的计算机内存是大端字节序还是小端字节序存储方式？[假装思索……]</p><ul><li>大小端判断很有可能成为你将来的面试题。以前我总结过这样的问题。</li><li>以后再附上链接：哈哈</li></ul><ul><li>（只想引入下面一句话）在网络数据流中同样有大小端之分，那么如何定义网络数据流的地址呢？</li></ul><p>【看图理解】</p><p><img src="http://p9ff104hp.bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E5%8F%91%E9%80%81.jpg" alt="图片加载失败"></p><p>【看图说话】</p><p><img src="http://p9ff104hp.bkt.clouddn.com/%E8%A7%84%E5%AE%9A.jpg" alt="图片加载失败"></p><ul><li>如果发送主机是小端，就要准换成大端再发送，如果是大端，直接发送即可。</li></ul><blockquote><p>为了使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">   <span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> hostlong);</span><br><span class="line">   <span class="keyword">uint16_t</span> htons(<span class="keyword">uint16_t</span> hostshort);</span><br><span class="line">   <span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> netlong);</span><br><span class="line">   <span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> netshort);</span><br></pre></td></tr></table></figure><blockquote><p>调用函数就能解决存储字节序不统一的问题</p></blockquote><h5 id="socket编程常见API："><a href="#socket编程常见API：" class="headerlink" title="socket编程常见API："></a>socket编程常见API：</h5><p>这部分只把函数列出来，详细介绍请戳作者下面博客：</p><p><strong> 请戳： </strong><a href="https://blog.csdn.net/m0_37925202/article/details/80286946" target="_blank" rel="noopener">socket套接字总结</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket文件描述符  (TCP/UDP,客户端+服务器)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="sockaddr结构："><a href="#sockaddr结构：" class="headerlink" title="sockaddr结构："></a>sockaddr结构：</h5><blockquote><p>socket API是一 层抽象的网络编程接口 ,适用于各种底层网络协议,如IPv4、IPv6.然而, 各种网络协议的地址格式各不相同。</p></blockquote><p><img src="http://p9ff104hp.bkt.clouddn.com/%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B.jpg" alt="图片加载失败"></p><ul><li><p>注意：socket API可以都用 struct sockaddr *类型表 , 在使用的时候需要强制转化成sockaddr_in; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数。</p><hr></li></ul><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><blockquote><p>通过上面的学习对UDP有个直观的认识，再详细讨论以下几点：</p></blockquote><ul><li>无连接</li></ul><blockquote><p>知道目的端的IP和端口号就能传输，不需要建立连接。</p></blockquote><ul><li>不可靠传输</li></ul><blockquote><p>没有确认机制，没有重传机制，如果因为网络故障无法发送到对方，UDP协议层也不会给应用层返回任何错误信息。</p></blockquote><ul><li>面向数据报</li></ul><blockquote><p>不能够灵活的控制读写数据的次数和数量。</p></blockquote><ul><li>以上几点在代码中还能得到学习和理解。</li></ul><h5 id="服务器和客户端是怎么运行起来的？"><a href="#服务器和客户端是怎么运行起来的？" class="headerlink" title="服务器和客户端是怎么运行起来的？"></a>服务器和客户端是怎么运行起来的？</h5><p>先说说什么是回显服务器：</p><p>回显服务器是最简单的服务器，客户端发起请求，服务器收到请求，然后客户端发送什么内容，服务器就给客户端返回什么内容。</p><ul><li><strong>服务器：</strong></li></ul><blockquote><p>1、创建socket</p></blockquote><blockquote><p>2、绑定端口</p></blockquote><blockquote><p>3、循环的读取数据</p></blockquote><blockquote><p>4、针对读取到的数据进行计算和处理</p></blockquote><blockquote><p>5、把处理后的结果发回客户端</p></blockquote><ul><li><strong>客户端：</strong></li></ul><blockquote><p>1、创建socket文件</p></blockquote><blockquote><p>2、给服务器发送请求</p></blockquote><blockquote><p>3、从服务器中读取结果。</p></blockquote><ul><li>有了步骤，实现起来就只需要把步骤翻译成Code了：</li></ul><h5 id="服务器实现"><a href="#服务器实现" class="headerlink" title="服务器实现"></a>服务器实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个套接字，并检测是否创建成功</span></span><br><span class="line">    <span class="keyword">int</span> sockSer = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockSer == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrSer</span>;</span>  <span class="comment">//创建一个记录地址信息的结构体</span></span><br><span class="line">    addrSer.sin_family = AF_INET;    <span class="comment">//使用AF_INET协议族</span></span><br><span class="line">    addrSer.sin_port = htons(<span class="number">5050</span>);     <span class="comment">//设置地址结构体中的端口号</span></span><br><span class="line">    addrSer.sin_addr.s_addr = inet_addr(<span class="string">"192.168.3.169"</span>);  <span class="comment">//设置通信ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字地址与所创建的套接字号联系起来，并检测是否绑定成功</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    <span class="keyword">int</span> res = bind(sockSer,(struct sockaddr*)&amp;addrSer, addrlen);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">256</span>];    <span class="comment">//申请一个发送数据缓存区</span></span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">256</span>];    <span class="comment">//申请一个接收数据缓存区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrCli</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  <span class="comment">//服务器一直循环接受客户端的请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        recvfrom(sockSer,recvbuf,<span class="number">256</span>,<span class="number">0</span>,(struct  sockaddr*)&amp;addrCli, &amp;addrlen);     <span class="comment">//从指定地址接收客户端数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cli:&gt;%s\n"</span>,recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ser:&gt;"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,sendbuf);</span><br><span class="line">        sendto(sockSer,sendbuf,<span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;addrCli, addrlen);    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个套接字，并检测是否创建成功</span></span><br><span class="line">    <span class="keyword">int</span> sockCli = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockCli == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addrSer.sin_family = AF_INET;    <span class="comment">//使用AF_INET协议族</span></span><br><span class="line">    addrSer.sin_port = htons(<span class="number">5050</span>);     <span class="comment">//设置地址结构体中的端口号</span></span><br><span class="line">    addrSer.sin_addr.s_addr = inet_addr(<span class="string">"192.168.3.169"</span>);  <span class="comment">//设置通信ip</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">256</span>];    <span class="comment">//申请一个发送数据缓存区</span></span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">256</span>];    <span class="comment">//申请一个接收数据缓存区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//向客户端发送数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cli:&gt;"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,sendbuf);</span><br><span class="line">        sendto(sockCli, sendbuf, <span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;addrSer, addrlen);</span><br><span class="line">        接收来自客户端的数据</span><br><span class="line">        recvfrom(sockCli, recvbuf, BUFFER_SIZE, <span class="number">0</span>, (struct sockaddr*)&amp;addrSer, &amp;addrlen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ser:&gt;%s\n"</span>, recvbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h4><p>1、UDP协议的特点以及和TCP协议的区别？</p><p>2、UDP连接建立过程分析、TCP呢？</p><p>3、UDP协议是不可靠的，为什么还要使用？</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;回显服务器的代码实现过程，文章加入了详细的设计过程以及其他的计算机网络理论知识。&lt;/li&gt;
&lt;li&gt;操作环境：CentOS 7.0 X64 操作系统、Vim编辑器、Gcc编译器。
    
    </summary>
    
      <category term="SO Kernal" scheme="http://askunix.github.io/categories/SO-Kernal/"/>
    
    
      <category term="计算机网络" scheme="http://askunix.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP协议" scheme="http://askunix.github.io/tags/UDP%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub + Blog【版本：小猪佩奇】</title>
    <link href="http://askunix.github.io/2018/05/20/Hexo+GitHub%20Blog/"/>
    <id>http://askunix.github.io/2018/05/20/Hexo+GitHub Blog/</id>
    <published>2018-05-20T08:30:11.534Z</published>
    <updated>2018-08-02T14:16:28.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><ul><li>利用周末时间搭建了Hexo + github + 个性化域名博客。</li><li>通过不断地测试和完善，实现了常用功能以及基本的页面美化。<a id="more"></a></li></ul><p><img src="http://p9ff104hp.bkt.clouddn.com/13.jpg" alt="图片加载失败"></p><h4 id="问题概况"><a href="#问题概况" class="headerlink" title="问题概况"></a>问题概况</h4><ul><li><p>在搭建过程中遇到了很多棘手的问题，在中途因为没有测试，还崩溃过，只能归零，从头再来。</p></li><li><p>非常感谢众多大神的博客，给了我很多帮助，推荐几个程序员技术交流网站/社区：知乎、简书、CSDN、掘金、牛客、GitHub。</p></li><li><p>因为有了第一次的经验和教训，所以第二次从环境搭建到站点/主题配置就一气呵成了。</p></li><li><p>我的博客后期用来管理优质文章、自己写的小项目、分享我喜欢的图片、音乐歌单、笔记等等，欢迎读者收藏。</p></li></ul><h4 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h4><p>1、<code>Atom</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/atom.png" alt="图片加载失败"></p><p>2、<code>Sublime Text 3</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/Sublime%20Text.png" alt="图片加载失败"></p><p>3、<code>NotePad ++</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/Notepad%20++.png" alt="图片加载失败"></p><p>4、<code>冰点文库下载器</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/%E5%86%B0%E7%82%B9%E6%96%87%E5%BA%93.png" alt="图片加载失败"></p><p>5、<code>LastActivity View</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/LastActivit.png" alt="图片加载失败"></p><p>6、<code>Xshell</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/xshell.png" alt="图片加载失败"></p><p>7、<code>Xftp 6</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/xftp.png" alt="图片加载失败"></p><p>8、<code>Mind Master</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/mindMaster.png" alt="图片加载失败"></p><p>9、<code>Fiddler</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/fiddler.png" alt="图片加载失败"></p><p>10、<code>VC++ 6.0 MSDN</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/MSDN.png" alt="图片加载失败"></p><p>11、<code>Typora</code></p><p><img src="http://p9ff104hp.bkt.clouddn.com/Typora.png" alt="图片加载失败"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;利用周末时间搭建了Hexo + github + 个性化域名博客。&lt;/li&gt;
&lt;li&gt;通过不断地测试和完善，实现了常用功能以及基本的页面美化。
    
    </summary>
    
      <category term="工具操作" scheme="http://askunix.github.io/categories/%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git" scheme="http://askunix.github.io/tags/Git/"/>
    
      <category term="技术" scheme="http://askunix.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
