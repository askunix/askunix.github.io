<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何进鸿的博客</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-25T12:36:24.317Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>何进鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于UDP协议的回显服务器实现</title>
    <link href="http://yoursite.com/2018/05/22/%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/22/基于UDP协议的回显服务器/</id>
    <published>2018-05-21T17:14:30.000Z</published>
    <updated>2018-05-25T12:36:24.317Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回显服务器的代码实现，文章加入了详细的设计过程以及其他的计算机网络理论知识。</p><p>实现环境：CentOS 7.0 操作系统<br>         Vim编辑器、Gcc编译器</p><a id="more"></a><h4 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h4><ul><li>本文的目的是写回显服务器，在撸代码之前，先来个热身。</li></ul><h5 id="IP地址是什么？"><a href="#IP地址是什么？" class="headerlink" title="IP地址是什么？"></a>IP地址是什么？</h5><p>IP地址有IPV4、IPV6之分，一般不特俗说明，默认就是IPV4。</p><blockquote><p>IP地址是用来标识不同的主机，每个主机都有唯一的IP地址；<br>对于IP4来说，IP地址是一个4字节，32位整数；<br>IP地址用“点分”制表示，如：192.168.1.11（用点分割的每个数范围0~255）。</p></blockquote><h5 id="源IP地址-amp-目的IP地址？"><a href="#源IP地址-amp-目的IP地址？" class="headerlink" title="源IP地址&amp;目的IP地址？"></a>源IP地址&amp;目的IP地址？</h5><blockquote><p>很容易理解，都是地址，和寄快递的收发地址一样，从上海发往西安的快递，源IP就是上海，目的IP就是西安。</p></blockquote><h5 id="端口号是什么？"><a href="#端口号是什么？" class="headerlink" title="端口号是什么？"></a>端口号是什么？</h5><ul><li>端口号是传输层协议内容</li></ul><blockquote><p>端口号是2字节196位整数；<br>端口号用来标识一个进程，告诉操作系统，当前数据要交给哪一个进程来处理；<br><strong>一个进程可以绑定多个端口号，但是一个端口号不可以绑定多个进程。</strong></p></blockquote><h5 id="源端口号-amp-目的端口号？"><a href="#源端口号-amp-目的端口号？" class="headerlink" title="源端口号&amp;目的端口号？"></a>源端口号&amp;目的端口号？</h5><blockquote><p>在源IP&amp;目的IP中，我们用的寄快递的例子帮助理解，在这里，还是用发快递帮助理解。源IP与目的IP标识了发件人地址和收件人的地址，地址有了，那么包裹就会交给快递员运送每个，快递员都有一个工号，工号是唯一的。这就对应了数据传输过程中，由哪个进程来处理数据。再来到寄快递问题上，有的快递包裹比较大，这就要多个快递员来运输，那么一个包裹由多个快递员运输，记在物流信息上就是这样的格式：一个包裹的目的地 + 多个快递员工号；这家公司接的都是大包裹，一个快递员只能送一个包裹。对应到网络传输中，就是一个进程可以绑定多个端口号，但一个端口号不可以绑定多个进程。</p></blockquote><hr><h4 id="函数介绍："><a href="#函数介绍：" class="headerlink" title="函数介绍："></a>函数介绍：</h4><ul><li>为后面撸代码介绍几个函数。</li></ul><h5 id="网络字节序："><a href="#网络字节序：" class="headerlink" title="网络字节序："></a>网络字节序：</h5><p>在C语言中我们知道，内存中的数据存储有大小端之分；数据在磁盘中存储也有大小端之分，在这里我还想啰嗦一个C语言问题，怎样判断自己的计算机内存是大端字节序还是小端字节序存储方式？[假装思索……]</p><ul><li>大小端判断很有可能成为你将来的面试题。以前我总结过这样的问题。</li><li>附上链接：</li></ul><ul><li>（只想引入下面一句话）在网络数据流中同样有大小端之分，那么如何定义网络数据流的地址呢？</li></ul><p>【看图理解】</p><p><img src="/img/数据发送.jpg" alt="图片加载失败"></p><p>【看图说话】</p><p><img src="/img/规定.jpg" alt="图片加载失败"></p><ul><li>如果发送主机是小端，就要准换成大端再发送，如果是大端，直接发送即可。</li></ul><blockquote><p>为了使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;arpa/inet.h&gt;</span><br><span class="line">   uint32_t htonl(uint32_t hostlong);</span><br><span class="line">   uint16_t htons(uint16_t hostshort);</span><br><span class="line">   uint32_t ntohl(uint32_t netlong);</span><br><span class="line">   uint16_t ntohs(uint16_t netshort);</span><br></pre></td></tr></table></figure><blockquote><p>调用函数就能解决存储字节序不统一的问题</p></blockquote><h5 id="socket编程常见API："><a href="#socket编程常见API：" class="headerlink" title="socket编程常见API："></a>socket编程常见API：</h5><p>这部分只把函数列出来，详细介绍请戳作者下面博客：</p><p><a href="https://blog.csdn.net/m0_37925202/article/details/80286946" target="_blank" rel="noopener">socket套接字</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建socket文件描述符  (TCP/UDP,客户端+服务器)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭套接字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="sockaddr结构："><a href="#sockaddr结构：" class="headerlink" title="sockaddr结构："></a>sockaddr结构：</h5><blockquote><p>socket API是一 层抽象的网络编程接口 ,适用于各种底层网络协议,如IPv4、IPv6.然而, 各种网络协议的地址格式各不相同。</p></blockquote><p><img src="/img/三种类型.jpg" alt="图片加载失败"></p><ul><li><p>注意：socket API可以都用 struct sockaddr *类型表 , 在使用的时候需要强制转化成sockaddr_in; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数。</p><hr></li></ul><h4 id="UDP协议："><a href="#UDP协议：" class="headerlink" title="UDP协议："></a>UDP协议：</h4><blockquote><p>通过上面的学习对UDP有个直观的认识，再详细讨论以下几点：</p></blockquote><ul><li>无连接</li></ul><blockquote><p>知道目的端的IP和端口号就能传输，不需要建立连接。</p></blockquote><ul><li>不可靠传输</li></ul><blockquote><p>没有确认机制，没有重传机制，如果因为网络故障无法发送到对方，UDP协议层也不会给应用层返回任何错误信息。</p></blockquote><ul><li>面向数据报</li></ul><blockquote><p>不能够灵活的控制读写数据的次数和数量。</p></blockquote><ul><li>以上几点在代码中还能得到学习和理解。</li></ul><h5 id="服务器和客户端是怎么运行起来的？"><a href="#服务器和客户端是怎么运行起来的？" class="headerlink" title="服务器和客户端是怎么运行起来的？"></a>服务器和客户端是怎么运行起来的？</h5><p>先说说什么是回显服务器：</p><p>回显服务器是最简单的服务器，客户端发起请求，服务器收到请求，然后客户端发送什么内容，服务器就给客户端返回什么内容。</p><ul><li><strong>服务器：</strong></li></ul><blockquote><p>1、创建socket</p></blockquote><blockquote><p>2、绑定端口</p></blockquote><blockquote><p>3、循环的读取数据</p></blockquote><blockquote><p>4、针对读取到的数据进行计算和处理</p></blockquote><blockquote><p>5、把处理后的结果发回客户端</p></blockquote><ul><li><strong>客户端：</strong></li></ul><blockquote><p>1、创建socket文件</p></blockquote><blockquote><p>2、给服务器发送请求</p></blockquote><blockquote><p>3、从服务器中读取结果。</p></blockquote><ul><li>有了步骤，实现起来就只需要把步骤翻译成Code了：</li></ul><h5 id="服务器实现："><a href="#服务器实现：" class="headerlink" title="服务器实现："></a>服务器实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个套接字，并检测是否创建成功</span></span><br><span class="line">    <span class="keyword">int</span> sockSer = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockSer == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrSer</span>;</span>  <span class="comment">//创建一个记录地址信息的结构体</span></span><br><span class="line">    addrSer.sin_family = AF_INET;    <span class="comment">//使用AF_INET协议族</span></span><br><span class="line">    addrSer.sin_port = htons(<span class="number">5050</span>);     <span class="comment">//设置地址结构体中的端口号</span></span><br><span class="line">    addrSer.sin_addr.s_addr = inet_addr(<span class="string">"192.168.3.169"</span>);  <span class="comment">//设置通信ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字地址与所创建的套接字号联系起来，并检测是否绑定成功</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line">    <span class="keyword">int</span> res = bind(sockSer,(struct sockaddr*)&amp;addrSer, addrlen);</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">256</span>];    <span class="comment">//申请一个发送数据缓存区</span></span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">256</span>];    <span class="comment">//申请一个接收数据缓存区</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addrCli</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  <span class="comment">//服务器一直循环接受客户端的请求</span></span><br><span class="line">    &#123;</span><br><span class="line">        recvfrom(sockSer,recvbuf,<span class="number">256</span>,<span class="number">0</span>,(struct  sockaddr*)&amp;addrCli, &amp;addrlen);     <span class="comment">//从指定地址接收客户端数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cli:&gt;%s\n"</span>,recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ser:&gt;"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,sendbuf);</span><br><span class="line">        sendto(sockSer,sendbuf,<span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>,<span class="number">0</span>,(struct sockaddr*)&amp;addrCli, addrlen);    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="客户端实现："><a href="#客户端实现：" class="headerlink" title="客户端实现："></a>客户端实现：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个套接字，并检测是否创建成功</span></span><br><span class="line">    <span class="keyword">int</span> sockCli = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sockCli == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addrSer.sin_family = AF_INET;    <span class="comment">//使用AF_INET协议族</span></span><br><span class="line">    addrSer.sin_port = htons(<span class="number">5050</span>);     <span class="comment">//设置地址结构体中的端口号</span></span><br><span class="line">    addrSer.sin_addr.s_addr = inet_addr(<span class="string">"192.168.3.169"</span>);  <span class="comment">//设置通信ip</span></span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen = <span class="keyword">sizeof</span>(struct sockaddr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">256</span>];    <span class="comment">//申请一个发送数据缓存区</span></span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">256</span>];    <span class="comment">//申请一个接收数据缓存区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//向客户端发送数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cli:&gt;"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,sendbuf);</span><br><span class="line">        sendto(sockCli, sendbuf, <span class="built_in">strlen</span>(sendbuf)+<span class="number">1</span>, <span class="number">0</span>, (struct sockaddr*)&amp;addrSer, addrlen);</span><br><span class="line">        接收来自客户端的数据</span><br><span class="line">        recvfrom(sockCli, recvbuf, BUFFER_SIZE, <span class="number">0</span>, (struct sockaddr*)&amp;addrSer, &amp;addrlen);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Ser:&gt;%s\n"</span>, recvbuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回显服务器的代码实现，文章加入了详细的设计过程以及其他的计算机网络理论知识。&lt;/p&gt;
&lt;p&gt;实现环境：CentOS 7.0 操作系统&lt;br&gt;         Vim编辑器、Gcc编译器&lt;/p&gt;
    
    </summary>
    
      <category term="SO Kernal" scheme="http://yoursite.com/categories/SO-Kernal/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="UDP协议" scheme="http://yoursite.com/tags/UDP%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="回显服务器" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建经历</title>
    <link href="http://yoursite.com/2018/05/20/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2NO3/"/>
    <id>http://yoursite.com/2018/05/20/测试博客NO3/</id>
    <published>2018-05-20T08:42:54.000Z</published>
    <updated>2018-05-25T12:36:21.081Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><p><img src="/img/hexo01.jpg" alt="图片加载失败"></p><ul><li><p>利用周末时间搭建了Hexo + github + 个性化域名博客</p></li><li><p>通过不断地测试和完善，实现了常用功能以及基本的页面美化</p><a id="more"></a></li><li><p>在搭建过程中遇到了很多棘手的问题，在中途因为没有测试，还崩溃过，只能归零，从头再来。</p></li></ul><ul><li>非常感谢IT界众多大神的博客，给了我很多帮助，技术交流，请到知乎、简书、CSDN、github</li></ul><ul><li>第二次搭建，我曾想到用Coding建仓库，但是后来想到github的影响力等，毕竟github是全球同性社交平台，呵呵</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/img/hexo01.jpg&quot; alt=&quot;图片加载失败&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用周末时间搭建了Hexo + github + 个性化域名博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过不断地测试和完善，实现了常用功能以及基本的页面美化&lt;/p&gt;
    
    </summary>
    
      <category term="操作指南" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github page" scheme="http://yoursite.com/tags/github-page/"/>
    
  </entry>
  
</feed>
