<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【排序算法】快速排序（可视化描述，三种方法实现，四种方法优化）]]></title>
    <url>%2Fblog%2F2018%2F07%2F29%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这是快排的可视化动态图描述： 该方法的基本思想是： (1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”； (2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大； (3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 总结起来就是：挖坑思想 + 分治思想 对于分治思想，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。 最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列。 方法一：第一种方法就是直接选择这个数组的第一个元素或者最后一个元素作为基准进行排序。这种方法也是基本的快排做法，存在效率问题。 12345int SelectPivot(int arr[],int low,int high)//low第一个元素，high最后一个元素&#123; return arr[low];//选择选取序列的第一个元素作为基准&#125; 如果这个数组有序，那么每次只能使这个序列 -1，就会沦为冒泡排序，时间复杂度变成O(N^2)。 方法二：随机选择一个基准。 1234567891011/*随机选择枢轴的位置，区间在low和high之间*/int SelectPivotRandom(int arr[],int low,int high)&#123; //产生基准的位置 srand((unsigned)time(NULL)); int pivotPos = rand()%(high - low) + low; //把基准位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数 swap(arr[pivotPos],arr[low]); return arr[low];&#125; 由于基准的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n^2）。 但是数据相等的概率比较小，所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。“随机化快速排序可以满足一个人一辈子的人品需求”。 方法三：三数取中：效率最高的情况就是这个基准能将数组序列划分成等长度的两部分，但是这个数很难找出来，还容易拖慢快排速度。 这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为基准。 给定待排序序列为：8 1 4 9 6 3 5 2 7 0 左边为：8，右边为0，中间为6。 三个数排序后，中间那个数作为基准，则基准为6。 具体思想：对待排序序列中low、mid、high三个位置上数据进行排序，取他们中间的那个数据作为基准，并用0下标元素存储该基准。 123456789101112131415161718192021222324/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/int SelectPivotMedianOfThree(int arr[],int low,int high) //三数取中&#123; int mid = low + ((high - low) &gt;&gt; 1);//计算数组中间的元素的下标 //使用三数取中法选择枢轴 if (arr[mid] &gt; arr[high]) //目标: arr[mid] &lt;= arr[high] &#123; swap(arr[mid],arr[high]); &#125; if (arr[low] &gt; arr[high]) //目标: arr[low] &lt;= arr[high] &#123; swap(arr[low],arr[high]); &#125; if (arr[mid] &gt; arr[low]) //目标: arr[low] &gt;= arr[mid] &#123; swap(arr[mid],arr[low]); &#125; //此时，arr[mid] &lt;= arr[low] &lt;= arr[high] return arr[low]; //low的位置上保存这三个位置中间的值 //分割时可以直接使用low位置的元素作为基准，而不用改变分割函数了&#125; 性能测试方法： 1、随机生成100万个数据对函数进行性能测试； 2、生成100万个相等数据，测试函数性能； 3、生成100万个有序数据，测试函数性能。 优化一：对于很小或者部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排。 截止范围：待排序序列长度N = 10，（在5 - 20之间可能都会存在这样的效率问题） 12345if (high - low + 1 &lt; 10)&#123; InsertSort(arr,low,high); return;&#125;//else时，正常执行快排 优化二：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。 待排序序列 1 4 6 7 6 6 7 6 8 6 三数取中选取基准：基准key = 6 本次划分后，未对与key元素相等处理的结果：1 4 6 6 7 6 7 6 8 6 下次的两个子序列为：1 4 6 和 7 6 7 6 8 6 本次划分后，对与key元素相等处理的结果：1 4 6 6 6 6 6 7 8 7 下次的两个子序列为：1 4 和 7 8 7 在一次划分后，把与key相等的元素聚在一起，能减少迭代次数，效率会提高不少。 具体思想： 第一步，在划分过程中，把与key相等元素放入数组的两端 第二步，划分结束后，把与key相等的元素移到枢轴周围 变态代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void QSort(int arr[],int low,int high)&#123; int first = low; int last = high; int left = low; int right = high; int leftLen = 0; int rightLen = 0; if (high - low + 1 &lt; 10) &#123; InsertSort(arr,low,high); return; &#125; //一次分割 int key = SelectPivotMedianOfThree(arr,low,high);//使用三数取中法选择基准 while(low &lt; high) &#123; while(high &gt; low &amp;&amp; arr[high] &gt;= key) &#123; if (arr[high] == key)//处理相等元素 &#123; swap(arr[right],arr[high]); right--; rightLen++; &#125; high--; &#125; arr[low] = arr[high]; while(high &gt; low &amp;&amp; arr[low] &lt;= key) &#123; if (arr[low] == key) &#123; swap(arr[left],arr[low]); left++; leftLen++; &#125; low++; &#125; arr[high] = arr[low]; &#125; arr[low] = key; //一次快排结束 //把与枢轴key相同的元素移到枢轴最终位置周围 int i = low - 1; int j = first; while(j &lt; left &amp;&amp; arr[i] != key) &#123; swap(arr[i],arr[j]); i--; j++; &#125; i = low + 1; j = last; while(j &gt; right &amp;&amp; arr[i] != key) &#123; swap(arr[i],arr[j]); i++; j--; &#125; QSort(arr,first,low - 1 - leftLen); QSort(arr,low + 1 + rightLen,last);&#125; 这是一个性能测试分析图：（大神的） 测试数据分析：三数取中选择枢轴+插排+聚集相等元素的组合，效果竟然好的出奇。其实这里，插排的作用还是不怎么大的。 优化三：快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化。 优点：如果待排序的序列划分极端不平衡，递归的深度将趋近于n，而栈的大小是很有限的，每次递归调用都会耗费一定的栈空间，函数的参数越多，每次递归耗费的空间也越多。优化后，可以缩减堆栈深度，由原来的O(n)缩减为O(logn)，将会提高性能。 1234567891011121314151617void QSort(int arr[],int low,int high)&#123; int pivotPos = -1; if (high - low + 1 &lt; 10) &#123; InsertSort(arr,low,high); return; &#125; while(low &lt; high) &#123; pivotPos = Partition(arr,low,high); QSort(arr,low,pivotPos-1); low = pivotPos + 1; &#125;&#125;/////注意：在第一次递归后，low就没用了，此时第二次递归可以使用循环代替///// 测试数据分析： 测试数据分析：其实这种优化编译器会自己优化，相比不使用优化的方法，时间几乎没有减少. 优化四：使用并行或多线程处理子序列。（不知道怎么实现，但可以简单理解下处理过程，以及多线程实现存在的问题。） 复杂度问题：当划分均衡时，平均时间复杂度O(nlogn），空间O(logn）；当划分完全不均衡时，最坏时间O(n²），空间O(n）。 快排为什么这么快：推荐阅读：数学之美番外篇：快排为什么那样快 总结一下就是三个原因： 堆排序平均最坏时间复杂度都为O(nlogn），但为什么实际应用中快排效果好于堆排？ 虽然都是O(nlogn）级别，但是时间复杂度是近似得到的，快排前面的系数更小，所以性能更好些。 堆排比较交换次数更多。 第三个原因也是最主要的原因，和cpu高速缓冲存储器（cache）有关。由计算机组成原理，我们了解过，cpu有一块高速缓存区（cache）。堆排序要经常处理距离很远的数，不符合局部性原理，会导致cache命中率降低，频繁读写内存。 完整代码：点击即可查看]]></content>
      <categories>
        <category>编程之美</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>快速排序</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【排序算法】直接插入排序 & 折半插入排序（二分法插入排序）]]></title>
    <url>%2Fblog%2F2018%2F07%2F29%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这是插排的可视化动态图描述： 排序：就是将一组杂乱无章的数据按照一定的规律(升序或降序)组织起来。数据表：待排序数据元素的有限集合。排序码：通常数据元素有多个属性域，其中有一个属性域可用来区分元素，作为排序依据，该域即为排序码。 排序算法的性能评估：一个算法执行时间是衡量算法好坏的重要参数。排序算法的时间开销可用算法中的数据交换次数，和数据移动次数来衡量。 直接插入排序算法 算法思想：当插入第 i 个元素时，前面的 i-1 个元素已经有序。其实直接插入排序就是拿一个数，放到前面有序的数中就可以了。具体怎么放，不管是循环交换两个数的位置，还是先找到位置，再将该位置后面的数顺移，都没毛病的。 #####算法性质： 直接排序算法是稳定的， 算法的时间复杂度为O(n^2)， 最好是用于量小、接近有序的数据。 代码实现：12345678910111213141516template&lt;typename T&gt;void INsert_Sort(T *array, int len)&#123; int key = 0; int end = 0; for (int i = 1; i &lt; len; i++) &#123; key = array[i]; for (end = i - 1; (end &gt;= 0) &amp;&amp; array[end] &gt; key; end--) &#123; array[end + 1] = array[end]; &#125; array[end + 1] = key; &#125;&#125; 刚在前面直接插入排序算法性质中说最好用于数据量小且基本有序的的情况。当数据量比较大时，时间会大量的耗费在移动和比较元素上，导致性能降低。因此可以从元素比较和移动上来优化算法。 折半插入排序算法 折半插入排序又称二分法插入排序。和直接插入排序算法不同的是：在插入元素时，利用折半搜索法寻找插入位置。 算法思想：过程同直接插入排序，仅仅是在找插入位置时，不是顺序遍历，而是二分法查找位置。因为：如果要找地 i 个元素的插入位置，那么第 i-1 个元素是已经有序的，可以用二分查找来寻找位置。 算法分析： 时间复杂度：折半插入排序仅仅是减少了比较元素的次数，约为O(nlogn)，而且该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n；而元素的移动次数没有改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍然为O(n²)，但它的效果还是比直接插入排序要好。 空间复杂度：排序只需要一个位置来暂存元素，因此空间复杂度为O（1）。 代码实现：12345678910111213141516171819202122232425262728void Bin_Insert_Sort(int* a, int n)&#123; int Low; int High; int Middle; for (int i = 1; i &lt; n; ++i) &#123; Low = 0; High = i - 1; // 求取插入位置 while (Low &lt;= High) &#123; Middle = (Low + High) / 2; if (a[Middle] &gt; a[i]) High = Middle - 1; else Low = Middle + 1; &#125; // 插入 for (int j = i - 1; j &gt; High; --j) &#123; swap(a[j], a[j + 1]); //这里也可以挨个移动元素后插入 &#125; &#125;&#125;]]></content>
      <categories>
        <category>编程之美</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序算法</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长连接与短连接]]></title>
    <url>%2Fblog%2F2018%2F07%2F14%2F%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[1、HTTP协议与TCP协议的关系？？HTTP的长连接和短连接实质上是TCP的长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP层：解决网络路由和寻址问题TCP协议：解决如何在IP层之上可靠的传输数据报，并在另一端收到发送的包，并且顺序与发出顺序一致。TCP有可靠，面向连接特点。 2、如何理解HTTP协议是无状态的？？无状态指的是协议对事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器网页和你之前打开它之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接协议）。 3、什么是长连接、短连接？？在HTTP/1.0 中，默认使用短连接。就是说：浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。 如果客户端浏览器访问某个HTML或者其他类型的Web页面中包含其他Web资源的这种情况，如：JavaScript文件、图像文件、CSS文件等，浏览器遇到这样的Web资源，就会建立一个会话。 从 HTTP/1.1 起，默认使用长连接，保持连接持续性。一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的的网页，会继续使用这一条已经建立好的连接。 Keep-Alive不会永久保持连接，它有一个保持的时间，可以在不同服务器软件中设定这个时间（Apache）。要实现长连接，客户端、服务器端首先得支持。 HTTP协议长连接、短连接实质上是TCP协议的长连接、短连接。 TCP短连接模拟一下TCP短连接的情况，Client向server发起连接请求，server接到请求，然后双方建立连接，Client向server发送消息，server回应client，然后一次读写就完成了，这是双方任意一放都可以发起close请求。一般都是client发起close请求。 短连接优点： 管理起来简单，存在的连接都是有用的，不需要额外的控制手段。 TCP长连接模拟TCP长连接情况：client向server发送连接请求，server接受client连接，双方建立连接，client与server完成一次读写之后，他们并不会主动关闭，后续的读写操作会继续使用这个连接。 首先说一下TCP/IP上说到的TCP保活功能，保活功能主要为服务器应用提供，服务器应用希望知道客户端主机是否崩溃，从而可以代表客户使用资源。如果客户已经消失，使得服务器上保留一半开放的连接，而服务器又在等待来自客户端的数据，保活功能就是试图在服务器端检测这种半开放的连接。 如果给定的连接在两个小时内没有任何的动作，则服务器就向客户端发送一个探测报文段， 客户端必须处于以下四种转态。 1、客户端主机依然正常运行，并从服务器可达，客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时之后将保活计时器复位。 2、客户端已经崩溃，并且关闭或者正在重启。在任何一种情况下，客户端的TCP都没有响应，那么服务器端也就不能收到探测响应。并在75秒后超时，服务器共发送10个这样的探测，每个间隔75秒，如果客户端没有收到一个响应，就认为客户端主机已经关闭并终止连接。 3、客户端主机已经崩溃，但是已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。 4、客户端正常运行，但服务器不可达，类似2.TCP能发现的就是没有收到的响应。 短连接步骤：建立连接–数据传输–关闭连接 —— 长连接步骤：建立连接–数据传输–（保持连接）–数据传输–数据传输–关闭连接 —— 4、长连接和短连接的优缺点？？由上可知，长连接省去了较多的TCP建立、关闭操作，减少了浪费，节约时间。对于频繁请求资源的客户来说，适合用长连接。不过保活功能探测周期比较长，而且只能探测TCP连接的存活，遇到恶意连接，保活功能就有点不够用了。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。 5. 什么时候用长连接，短连接？长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况，每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。 例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。 如果用长连接而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。]]></content>
      <categories>
        <category>SO Kernal</category>
      </categories>
      <tags>
        <tag>长连接</tag>
        <tag>短连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程之美】链表面试题汇总版]]></title>
    <url>%2Fblog%2F2018%2F06%2F21%2F%E3%80%90%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%91%E9%93%BE%E8%A1%A8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%E7%89%88%2F</url>
    <content type="text"><![CDATA[写在前面 对于不带头结点的单链表操作，是在面试中经常出现的，在此对于常见链表操作进行总结，操作：有序链表合并、链表反转、链表排序、找倒数第K个节点、非头节点前插入data、删除非尾节点、约瑟夫环、带环链表环的大小等等 function.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#ifndef __FUNCTION_H__#define __FUNCTION_H__#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;malloc.h&gt;#define DataType intstruct Node&#123; DataType data; struct Node* _pNext;&#125;;typedef struct Node Node;typedef Node *pNode;pNode InitNodeList(pNode *pHead);//初始化pNode BuyNewNode(DataType data);//新建节点void InsertNodeByFrontToTail(pNode *pHead, DataType data);//头插法void PrintNodeProntToTail(pNode pHead);//正序打印void InserttNodeByTailToFront(pNode *pHead, DataType data);//尾插法pNode ReceiveNodeList(pNode pHead);//反转链表—一般方法pNode ReceiveNodeList_DG(pNode pHead);//反转链表——递归实现pNode MeryTwoSortNodeChangeOneSortNode(pNode pHead1, pNode pHead2);//合并两个有序单链表——一般方法pNode MeryTwoSortNodeChangeOneSortNode_DG(pNode pHead1, pNode pHead2);//合并两个有序单链表——递归实现void BubbleSortNodeList(pNode pHead);//链表排序——冒泡法实现pNode SearchMIdNode(pNode pHead);//查找中间节点——快慢指针法pNode FindLastKNode(pNode pHead, int key);//找到倒数第K个节点void InsertNotIntoKHead(pNode pos, DataType data);// 非头结点前插入datapNode FindDataInNodeList(pNode pHead, DataType k);//寻找链表中data为K的节点void DeleteLastKNode(pNode pHead, int key);//删除倒数第K个节点void DeleteNotTailNode(pNode pos);//删除单链表的非尾结点void GetCircleForJoseph(pNode pHead);//构造约瑟夫环void GetJosephCircle(pNode pHead, size_t K);//单链表实现约瑟夫环void GetCircleForList(pNode pHead);//构造带环链表pNode isHaveCircle(pNode pHead);//判断链表是否带环int GetCircleLength(pNode pHead);//求环的长度pNode GetCircleIntoNode(pNode pHead);//求环的入口点pNode pFrontNode(pNode pHead);//返回链表第一个节点pNode pTailNode(pNode pHead); //返回链表最后一个节点void InsertNotHead(pNode pos, DataType data);// 非头结点前插入data#endif function.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451#include"function.h"pNode BuyNewNode(DataType data)&#123; pNode pTempNode = NULL; pTempNode = (pNode)malloc(sizeof(pNode)); if (pTempNode) &#123; pTempNode-&gt;data = data; pTempNode-&gt;_pNext = NULL; &#125; return pTempNode;&#125;void InsertNodeByFrontToTail(pNode *pHead, DataType data)&#123; pNode pTemp = NULL; if (*pHead == NULL) *pHead = BuyNewNode(data); else &#123; pTemp = BuyNewNode(data); pTemp-&gt;_pNext = *pHead; *pHead = pTemp; &#125;&#125;void InserttNodeByTailToFront(pNode *pHead, DataType data)&#123; pNode pTest = NULL; pNode pCur = *pHead; pTest = BuyNewNode(data); if (*pHead == NULL) (*pHead) = pTest; else &#123; while (NULL != pCur-&gt;_pNext) &#123; pCur = pCur-&gt;_pNext; &#125; pCur -&gt;_pNext = pTest; &#125;&#125;void PrintNodeProntToTail(pNode pHead)&#123; //pNode pTemp = pHead; if (NULL == pHead) return; while (pHead != NULL) &#123; printf("%d -&gt; ", pHead-&gt;data); pHead = pHead-&gt;_pNext; &#125; printf("NULL"); printf("\n");&#125;pNode ReceiveNodeList(pNode pHead)&#123; pNode pTest = pHead; //pNode pNextNode = NULL; pNode pPre = NULL; //pNode pReverse = NULL; if (pHead == NULL || pHead-&gt;_pNext == NULL) return pHead; while (pTest != NULL) &#123; pNode pNextNode = pTest-&gt;_pNext; pTest-&gt;_pNext = pPre; pPre = pTest; pTest = pNextNode; &#125; return pPre;&#125;pNode ReceiveNodeList_DG(pNode pHead)&#123; pNode pNewNode = NULL; if (pHead == NULL || pHead-&gt;_pNext == NULL) return pHead; pNewNode = ReceiveNodeList_DG(pHead-&gt;_pNext); pHead-&gt;_pNext-&gt;_pNext = pHead; //翻转链表的指向 pHead-&gt;_pNext = NULL; //记得赋值NULL，防止链表错乱 return pNewNode; //新链表头永远指向的是原链表的链尾&#125;pNode MeryTwoSortNodeChangeOneSortNode(pNode pHead1, pNode pHead2)&#123; pNode pNewNode = NULL; pNode pTemp = NULL; pNode pNextNode = NULL; unsigned int Node1Len = 0; unsigned int Node2Len = 0; while (pHead1-&gt;_pNext != NULL) &#123; ++Node1Len; &#125; while (pHead1-&gt;_pNext != NULL) &#123; ++Node2Len; &#125; if (Node1Len &lt; Node2Len) //长的链表为pHead1 &#123; pTemp = pHead1; pHead1 = pHead2; pHead2 = pTemp; &#125; while (pHead1 != NULL) &#123; if (pHead1-&gt;data &lt; pHead2-&gt;data) &#123; pNextNode = pHead1; pHead1 = pHead1-&gt;_pNext; pNextNode = pNextNode-&gt;_pNext; &#125; pNextNode = pHead2; pHead2 = pHead2-&gt;_pNext; pNextNode = pNextNode-&gt;_pNext; &#125; if (pHead1 == NULL) return pNewNode; else &#123; pNextNode = pHead1; &#125; return pNewNode;&#125;pNode MeryTwoSortNodeChangeOneSortNode_DG(pNode pHead1, pNode pHead2)&#123; pNode pNewHead = NULL; if (pHead1 == NULL) return pHead2; else if (pHead2 == NULL) return pHead1; else &#123; if (pHead1-&gt;data &gt; pHead2-&gt;data) &#123; pNewHead = pHead2; pNewHead-&gt;_pNext = MeryTwoSortNodeChangeOneSortNode_DG( pHead1, pHead2-&gt;_pNext); &#125; else &#123; pNewHead = pHead1; pNewHead-&gt;_pNext = MeryTwoSortNodeChangeOneSortNode_DG(pHead1-&gt;_pNext, pHead2); &#125; &#125; return pNewHead;&#125;void BubbleSortNodeList(pNode pHead)&#123; int pTempNode = 0; pNode pTail = NULL; pNode pPreCur = NULL; pNode pCur = NULL; int isFlag = 1; if (pHead == NULL || pHead-&gt;_pNext == NULL) &#123; return; &#125; while (pHead != pTail) &#123; isFlag = 0; pPreCur = pHead; pCur = pHead-&gt;_pNext; while (pCur != pTail) &#123; if (pCur-&gt;data &lt; pPreCur-&gt;data) &#123; pTempNode = pCur-&gt;data; pCur-&gt;data = pPreCur-&gt;data; pPreCur-&gt;data = pTempNode; isFlag = 1; &#125; pPreCur = pCur; pCur = pCur-&gt;_pNext; &#125; if (!isFlag) return; pTail = pPreCur; &#125;&#125;pNode SearchMIdNode(pNode pHead)&#123; pNode pFast = pHead; pNode pSlow = pHead; if (pHead == NULL || pHead-&gt;_pNext == NULL) return NULL; while (NULL != pFast &amp;&amp; NULL != pFast-&gt;_pNext) &#123; pSlow = pSlow-&gt;_pNext; pFast = pFast-&gt;_pNext-&gt;_pNext; &#125; return pSlow;&#125;pNode FindLastKNode(pNode pHead, int key)&#123; pNode pCur = pHead; pNode pSlow = pHead; pNode pFast = pHead; if (pHead == NULL ) &#123; return NULL; &#125; while (key--) &#123; if (pFast == NULL) return NULL; pFast = pFast-&gt;_pNext; &#125; while (pFast != NULL) &#123; pFast = pFast-&gt;_pNext; pSlow = pSlow-&gt;_pNext; &#125; return pSlow;&#125;void DeleteLastKNode(pNode pHead, int key)&#123; pNode pPosDelNode = FindLastKNode(pHead, key+1); if (pPosDelNode == pHead) &#123; free(pPosDelNode); return; &#125; pPosDelNode-&gt;_pNext = pPosDelNode-&gt;_pNext-&gt;_pNext;&#125;pNode FindDataInNodeList(pNode pHead, DataType k)&#123; pNode pCur = pHead; while (pCur != NULL) &#123; if (pCur-&gt;data == k) &#123; return pCur; &#125; pCur = pCur-&gt;_pNext; &#125; return NULL;&#125;pNode pFrontNode(pNode pHead) //返回链表第一个节点&#123; pNode pPcur = pHead; if (pHead == NULL) return NULL; return pPcur;&#125;pNode pTailNode(pNode pHead) //返回链表最后一个节点&#123; pNode pPcur = pHead; if (pHead == NULL) return NULL; while (pPcur != NULL &amp;&amp; pPcur-&gt;_pNext != NULL) &#123; pPcur = pPcur-&gt;_pNext; &#125; return pPcur;&#125;void GetCircleForList(pNode pHead)&#123; pNode pTemp = NULL; pTemp = FindDataInNodeList(pHead, 9); pTemp-&gt;_pNext = FindDataInNodeList(pHead, 7);&#125;pNode isHaveCircle(pNode pHead)&#123; pNode pSlowNode = pHead; pNode pFastNode = pHead; if (pHead == NULL) return NULL; while (pFastNode != pSlowNode &amp;&amp; pFastNode-&gt;_pNext != NULL) &#123; pFastNode = pFastNode-&gt;_pNext-&gt;_pNext; pSlowNode = pSlowNode-&gt;_pNext; &#125; return pSlowNode;&#125;int GetCircleLength(pNode pHead)&#123; pNode MeetNode = NULL; pNode pCur = NULL; size_t count = 0; if (isHaveCircle(pHead) == NULL) return 0; MeetNode = isHaveCircle(pHead); pCur = MeetNode-&gt;_pNext; while (pCur != MeetNode) &#123; count++; pCur = pCur-&gt;_pNext; &#125; return count;&#125;pNode GetCircleIntoNode(pNode pHead)&#123; pNode pCur = pHead; //在判断带环问题时，返回了环中快慢指针的相遇点。 pNode pMeetNodeInCircle = NULL; pMeetNodeInCircle = isHaveCircle(pHead); while (pCur != pMeetNodeInCircle) &#123; pCur = pCur-&gt;_pNext; pMeetNodeInCircle = pMeetNodeInCircle-&gt;_pNext; &#125; return pMeetNodeInCircle;&#125;void GetCircleForJoseph(pNode pHead)&#123; pNode front = NULL; pNode tail = NULL; front = pFrontNode(pHead); tail = pTailNode(pHead); tail-&gt;_pNext = front;&#125;void GetJosephCircle(pNode pHead, size_t K)&#123; int count = K; pNode pPreNode = pHead; pNode pCurNode = NULL; if (pHead == NULL) return; while (pPreNode-&gt;_pNext != pPreNode) &#123; count = K; while (--count) &#123; pCurNode = pPreNode; pPreNode = pPreNode-&gt;_pNext; &#125; pCurNode-&gt;_pNext = pPreNode-&gt;_pNext; printf("%d 号出去-&gt; ", pPreNode-&gt;data); //free(pPreNode); pPreNode = pPreNode-&gt;_pNext; &#125; //return pPreNode; printf("\n最后留下的人是： %d \n\n", pPreNode-&gt;data);&#125;int GetNodeListLength(pNode pHead)&#123; int count = 0; pNode pCur = pHead; if (pHead == NULL) return 0; while (pCur) &#123; count++; &#125; return count;&#125;void DeleteNotTailNode(pNode pos)&#123; assert(pos); pNode pTempNode = NULL; DataType temp = 0; if (pos == NULL) return; else &#123; //交换节点值 temp = pos-&gt;data; pos-&gt;data = pos-&gt;_pNext-&gt;data; pos-&gt;_pNext-&gt;data = temp; pTempNode = pos-&gt;_pNext; pos-&gt;_pNext = pTempNode-&gt;_pNext; //free(pTempNode); pTempNode = NULL; &#125;&#125;void InsertNotHead(pNode pos, DataType data)&#123; pNode pNewNode = NULL; pNode pCur = NULL; DataType pTemp = 0; if (pos == NULL) return; pNewNode = BuyNewNode(data); if (pNewNode == NULL) return; pCur = pos; pNewNode-&gt;_pNext = pCur-&gt;_pNext; pCur-&gt;_pNext = pNewNode; pTemp = pCur-&gt;data; pCur-&gt;data = pNewNode-&gt;data; pNewNode-&gt;data = pTemp;&#125; test.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include"function.h"void test()&#123; pNode pHead1 = NULL; pNode pHead2 = NULL; pNode pNewHead = NULL; pNode pHead3 = NULL; pNode pSortNode = NULL; pNode LastKNum = 0; pNode pReverseNode = NULL; pNode pR = NULL; pNode pHead4 = NULL; pNode pCirclieNode = NULL; size_t CircleLength = 0; pNode pIntoCircleNode = NULL; pNode pHead5 = NULL; pNode JueNode = NULL; pNode pHead6 = NULL; pNode pDelNode = NULL; pNode pInsertNode = NULL; pNode pH = NULL; InsertNodeByFrontToTail(&amp;pHead1, 9); InsertNodeByFrontToTail(&amp;pHead1, 8); InsertNodeByFrontToTail(&amp;pHead1, 6); InsertNodeByFrontToTail(&amp;pHead1, 5); InsertNodeByFrontToTail(&amp;pHead1, 2); InsertNodeByFrontToTail(&amp;pHead1, 1); PrintNodeProntToTail(pHead1); printf("\n链表的反转、还原:\n"); pReverseNode = ReceiveNodeList(pHead1); //反转 PrintNodeProntToTail(pReverseNode); pR = ReceiveNodeList_DG(pReverseNode); //反转 PrintNodeProntToTail(pR); pHead1 = pR; printf("\npHead1: "); PrintNodeProntToTail(pHead1); //还原pHead1 printf("\n"); InserttNodeByTailToFront(&amp;pHead2, 2); InserttNodeByTailToFront(&amp;pHead2, 3); InserttNodeByTailToFront(&amp;pHead2, 4); InserttNodeByTailToFront(&amp;pHead2, 5); InserttNodeByTailToFront(&amp;pHead2, 6); InserttNodeByTailToFront(&amp;pHead2, 7); printf("pHead2: "); PrintNodeProntToTail(pHead2); printf("\n两个有序链表的合并:\n"); pNewHead = MeryTwoSortNodeChangeOneSortNode_DG(pHead1, pHead2); PrintNodeProntToTail(pNewHead); //新建无序链表3 InsertNodeByFrontToTail(&amp;pHead3, 9); InsertNodeByFrontToTail(&amp;pHead3, 4); InsertNodeByFrontToTail(&amp;pHead3, 5); InsertNodeByFrontToTail(&amp;pHead3, 7); InsertNodeByFrontToTail(&amp;pHead3, 4); InsertNodeByFrontToTail(&amp;pHead3, 0); InsertNodeByFrontToTail(&amp;pHead3, 3); printf("\npHead3: "); PrintNodeProntToTail(pHead3); printf("\n排序好的链表3："); BubbleSortNodeList(pHead3); PrintNodeProntToTail(pHead3); printf("\npHead1中间节点：%d\n", (SearchMIdNode(pHead1)-&gt;data)); printf("\npNewHead中间节点：%d\n", (SearchMIdNode(pNewHead)-&gt;data)); printf("\n查找倒数第K个节点: "); LastKNum = FindLastKNode(pNewHead, 2); if (LastKNum != NULL) printf("%d\n", LastKNum-&gt;data); else printf("没有找到\n"); printf("\n删除倒数第K个节点\n"); DeleteLastKNode(pNewHead, 3); //构造一个带环链表4 InsertNodeByFrontToTail(&amp;pHead4, 9); InsertNodeByFrontToTail(&amp;pHead4, 8); InsertNodeByFrontToTail(&amp;pHead4, 6); InsertNodeByFrontToTail(&amp;pHead4, 5); InsertNodeByFrontToTail(&amp;pHead4, 2); InsertNodeByFrontToTail(&amp;pHead4, 1); InsertNodeByFrontToTail(&amp;pHead4, 3); InsertNodeByFrontToTail(&amp;pHead4, 0); InsertNodeByFrontToTail(&amp;pHead4, 7); printf("\n打印链表4：\n"); PrintNodeProntToTail(pHead4); printf("\n构造带环链表\n"); GetCircleForList(pHead4); printf("构造OK\n"); pCirclieNode = isHaveCircle(pHead4); if (pCirclieNode == NULL) printf("不带环\n"); else printf("带环\n"); printf("\n求环的长度："); //PrintNodeProntToTail(pHead4); CircleLength = GetCircleLength(pHead4); printf("%d", CircleLength); printf("\n求环的入口："); pIntoCircleNode = GetCircleIntoNode(pHead4); printf("%d\n", pIntoCircleNode-&gt;data); //构造一个链表，pHead5： 头插法构造单链表 InsertNodeByFrontToTail(&amp;pHead5, 9); InsertNodeByFrontToTail(&amp;pHead5, 8); InsertNodeByFrontToTail(&amp;pHead5, 7); InsertNodeByFrontToTail(&amp;pHead5, 6); InsertNodeByFrontToTail(&amp;pHead5, 5); InsertNodeByFrontToTail(&amp;pHead5, 4); InsertNodeByFrontToTail(&amp;pHead5, 3); InsertNodeByFrontToTail(&amp;pHead5, 2); InsertNodeByFrontToTail(&amp;pHead5, 1); printf("\n约瑟夫环问题:\n"); //构造环 GetCircleForJoseph(pHead5); printf("构造OK\n"); //PrintNodeProntToTail(pHead5); //约瑟夫环 GetJosephCircle(pHead5, 4); printf("构造链表6\n"); InsertNodeByFrontToTail(&amp;pHead6, 6); InsertNodeByFrontToTail(&amp;pHead6, 5); InsertNodeByFrontToTail(&amp;pHead6, 4); InsertNodeByFrontToTail(&amp;pHead6, 3); InsertNodeByFrontToTail(&amp;pHead6, 2); PrintNodeProntToTail(pHead6); printf("\n删除倒数第 3 个节点后，链表为：\n"); DeleteLastKNode(pHead6, 3); PrintNodeProntToTail(pHead6); printf("\n"); PrintNodeProntToTail(pHead6); printf("删除非尾节点 3 :\n"); pDelNode = FindDataInNodeList(pHead6, 3); DeleteNotTailNode(pDelNode); PrintNodeProntToTail(pHead6); printf("\n非头节点 5 前的插入:\n"); PrintNodeProntToTail(pHead6); pInsertNode = FindDataInNodeList(pHead6, 5); InsertNotHead(pInsertNode, 99); PrintNodeProntToTail(pHead6); printf("\n");&#125;int main()&#123; test(); return 0;&#125;]]></content>
      <categories>
        <category>编程之美</category>
      </categories>
      <tags>
        <tag>链表面试题</tag>
        <tag>编程之美</tag>
        <tag>无头单链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言版通讯录]]></title>
    <url>%2Fblog%2F2018%2F06%2F17%2FC%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%88%AC%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[写在前面 C语言通讯录可以用来存储1000个人的信息，每个人的信息包括姓名、年龄、性别、电话、住址,实现基本的增、删、查、改、排序、打印、清空基本功能。 思路分析: 首先我们可以分三个模块来解决这个问题，第一个模块我们需要一个头文件，这个头文件里可以包含一些相应信息，当实现文件和测试文件包含自己定义的头文件时便可以获得一些相关的信息。所以头文件里应该包括一个结构体，这个结构体里应包含姓名，性别，年龄，电话，住址。同时还可以定义一个结构体，这个结构体里包含通讯录，同时通讯录里人员的计数变量，将通讯录的地址传到别的地方便可以实现对它遍历或者其他操作。 第二个模块便是我们的测试函数，测试函数便可以实现我们的菜单打印，同时由我们接收不同的值便可以实现不同的操作，就是相应的方法的实现，这里很明显可以通过一个switch语句来控制功能选择，用do-while语句来控制重复选择的循环部分。 第三个模块便是我们的方法实现的函数，将模块2里定义的类型为通讯录的地址传到各个方法里，这样便可以实现对通讯录的操作。 代码实现头文件： &lt;contect.h&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma once;#include&lt;iostream&gt;#include&lt;Windows.h&gt;#include&lt;cstdio&gt;#define NAME_MAX 20#define TEL_MAX 12#define SEX_MAX 4#define MAX 1000using namespace std;enum&#123; Exit, Add, Del, Search, Modify, Empty, Sort, Show&#125;;struct Stu&#123; char Name[NAME_MAX]; int Age; char Tel[TEL_MAX]; char Sex[SEX_MAX]; char Address[50];&#125;;typedef struct Stu Stu;typedef struct Contact&#123; Stu Con[MAX]; //容量 int sz; //计数&#125;Contact, *pContact;//函数声明void InitContact(pContact pCon); //初始化void AddContact(pContact pCon); //新建void ShowContact(pContact pCon); //打印void DelContact(pContact pCon); //删除void SearchContact(pContact pCon); //查找void ModifyContact(pContact pCon); //修改void EmptyContact(pContact pCon); //清空void SortContact(pContact pCon); //排序 函数实现： contect.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#define _CRT_SECURE_NO_WARNINGS 1#include"contect.h"void InitContact(pContact pCon)&#123; pCon-&gt;sz = 0; memset(pCon-&gt;Con, 0, MAX * sizeof(Stu));&#125;void AddContact(pContact pCon)&#123; cout&lt;&lt;"请输入联系人姓名："; cin &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Name; cout &lt;&lt; "请输入联系人年龄："; cin &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Age; cout &lt;&lt; "请输入联系人电话："; cin &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Tel; cout &lt;&lt; "请输入联系人性别："; cin &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Sex; cout &lt;&lt; "请输入联系人地址："; cin &gt;&gt; pCon-&gt;Con[pCon-&gt;sz].Address; cout &lt;&lt; "═════联系人 " &lt;&lt; pCon-&gt;Con[pCon-&gt;sz].Name &lt;&lt; " 的信息保存成功════" &lt;&lt; endl &lt;&lt; endl; pCon-&gt;sz++;&#125;void ShowContact(pContact pCon)&#123; cout &lt;&lt; endl; cout &lt;&lt; "╔═════════════════════════════════════════════════════════════╗" &lt;&lt; endl; printf("%3s\t%6s\t%2s%16s%8s%20s\n","║序号","姓名","年龄","电话","性别","地址║"); for (int i = 0; i &lt; pCon-&gt;sz; i++) &#123; printf("%3d\t%6s\t%2d%16s%8s%20s\n", i + 1, pCon-&gt;Con[i].Name, pCon-&gt;Con[i].Age, pCon-&gt;Con[i].Tel, pCon-&gt;Con[i].Sex, pCon-&gt;Con[i].Address); &#125; cout &lt;&lt; "╚═════════════════════════════════════════════════════════════╝" &lt;&lt; endl; cout &lt;&lt; "温馨提示：输出完成！！！" &lt;&lt; endl &lt;&lt; endl;&#125;int FindInContact(pContact pCon, char *ch)&#123; for (int i = 0; i &lt; pCon-&gt;sz; i++) &#123; if (strcmp(pCon-&gt;Con[i].Name,ch) == 0) &#123; return i; &#125; &#125; return -1;&#125;void DelContact(pContact pCon)&#123; char ch[20]; ShowContact(pCon); cout &lt;&lt; "请输入上面通讯录中要删除联系人的姓名："; scanf("%s", &amp;ch); int NUM = FindInContact(pCon, ch); if (NULL == -1) &#123; printf("通讯录中没有该联系人！！！"); &#125; if (NUM &lt;= pCon-&gt;sz &amp;&amp; NUM != -1) &#123; for (int j = NUM; j &lt;= pCon-&gt;sz-1; j++) &#123; pCon-&gt;sz--; pCon-&gt;Con[j] = pCon-&gt;Con[j + 1]; printf("删除成功！！！\n"); &#125; &#125;&#125;void SearchContact(pContact pCon)&#123; char ch[20]; printf("请输出你要查找联系人的姓名："); scanf("%s", &amp;ch); int NUM = FindInContact(pCon, ch); if (NUM != -1) &#123; cout &lt;&lt; "╔═════════════════════════════════════════════════════════════╗" &lt;&lt; endl; printf("%3s\t%6s\t%2s%16s%8s%20s\n", "║序号", "姓名", "年龄", "电话", "性别", "地址║"); printf("%3d\t%6s\t%2d%16s%8s%20s\n", NUM + 1, pCon-&gt;Con[NUM].Name, pCon-&gt;Con[NUM].Age, pCon-&gt;Con[NUM].Tel, pCon-&gt;Con[NUM].Sex, pCon-&gt;Con[NUM].Address); cout &lt;&lt; "╚═════════════════════════════════════════════════════════════╝" &lt;&lt; endl; &#125; else printf("你要找的联系人不存在\n");&#125;void ModifyContact(pContact pCon)&#123; char ch[NAME_MAX]; printf("请输入要修改的联系人的姓名："); scanf("%s", &amp;ch); int NUM = FindInContact(pCon, ch); if (NUM != -1) &#123; cout &lt;&lt; "╔═════════════════════════════════════════════════════════════╗" &lt;&lt; endl; printf("%3s\t%6s\t%2s%16s%8s%20s\n", "║序号", "姓名", "年龄", "电话", "性别", "地址║"); printf("%3d\t%6s\t%2d%16s%8s%20s\n", NUM, pCon-&gt;Con[NUM].Name, pCon-&gt;Con[NUM].Age, pCon-&gt;Con[NUM].Tel, pCon-&gt;Con[NUM].Sex, pCon-&gt;Con[NUM].Address); cout &lt;&lt; "╚═════════════════════════════════════════════════════════════╝" &lt;&lt; endl; printf("请把姓名修改成："); scanf("%s", pCon-&gt;Con[NUM].Name); printf("请把年龄修改成："); scanf("%d", &amp;pCon-&gt;Con[NUM].Age); printf("请把电话修改成："); scanf("%s", pCon-&gt;Con[NUM].Tel); printf("请把性别修改成："); scanf("%s", pCon-&gt;Con[NUM].Sex); printf("请把地址修改成："); scanf("%s", pCon-&gt;Con[NUM].Address); &#125;&#125;void EmptyContact(pContact pCon)&#123; pCon-&gt;sz = 0; printf("清空成功！！！\n\n");&#125;void SortContact(pContact pCon)&#123; for (int i = 0; i &lt; pCon-&gt;sz; i++) &#123; for (int j = 0; j &lt; pCon-&gt;sz-i-1; j++) &#123; if (strcmp(pCon-&gt;Con[j].Name, pCon-&gt;Con[j + 1].Name)&gt;0) &#123; Stu temp; temp = pCon-&gt;Con[j]; pCon-&gt;Con[j] = pCon-&gt;Con[j + 1]; pCon-&gt;Con[j + 1] = temp; &#125; &#125; &#125;&#125; 测试函数： test.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include"contect.h"void menu()&#123; cout &lt;&lt; "╔═══════════════════════════════════════════════════╗" &lt;&lt; endl; cout &lt;&lt; "║═══════════════════ 通讯录 ══════════════════════║" &lt;&lt; endl; cout &lt;&lt; "║═══ ═══║" &lt;&lt; endl; cout &lt;&lt; "║═══ 1.新建 2.删除 ═══║" &lt;&lt; endl; cout &lt;&lt; "║═══ 3.查找 4.修改 ═══║" &lt;&lt; endl; cout &lt;&lt; "║═══ 5.清空 6.排序 ═══║" &lt;&lt; endl; cout &lt;&lt; "║═══ 7.打印 0.退出 ═══║" &lt;&lt; endl; cout &lt;&lt; "║═══ ═══║" &lt;&lt; endl; cout &lt;&lt; "╚═══════════════════════════════════════════════════╝" &lt;&lt; endl;&#125;void test()&#123; system("color c"); //改变背景 Contact my_con; InitContact(&amp;my_con); int input = 0; do &#123; menu(); cout &lt;&lt; "请选择："; cin &gt;&gt; input; switch (input) &#123; case Exit: break; case Add: AddContact(&amp;my_con); break; case Del: DelContact(&amp;my_con); break; case Search: SearchContact(&amp;my_con); break; case Modify: ModifyContact(&amp;my_con); break; case Empty: EmptyContact(&amp;my_con); break; case Sort: SortContact(&amp;my_con); break; case Show: ShowContact(&amp;my_con); break; default: cout &lt;&lt; "选择错误：-&gt;!!!" &lt;&lt; endl; break; &#125; &#125; while (input);&#125;int main()&#123; test(); return 0;&#125; 输出 问题思考1、改写成链表存储，不同存储结构的区别？ 2、动态版通讯录、文件版通讯录设计？ 3、编写大型通讯录系统，将通讯录数据存储在数据库中？]]></content>
      <categories>
        <category>小项目</category>
      </categories>
      <tags>
        <tag>C语言版通讯录</tag>
        <tag>结构体存储通讯录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP连接的建立和关闭过程及相关面试问题详解（三次握手&四次挥手&面试问题）]]></title>
    <url>%2Fblog%2F2018%2F06%2F15%2FTCP%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%26%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 三次握手、四次挥手问题是面试中一定会问到的，包括在《高质量C/C++编程》一书中也有类似的习题。这篇blog就TCP连接的建立和关闭过程及相关面试问题做一个详解，如有错误，望指正。如果对TCP还不了解，可以先阅读这篇文章： TCP固定头部结构详解 三次握手： 三次握手是就是TCP在建立连接时的过程。 TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。 A主机运行TCP客户端程序，B主机运行TCP服务器端程序，在A主机发送SYN之前，客户端和主机都处于CLOSED状态。 B主机先创建传输控制块PCB。准备接收客户端的请求，然后服务器端进入LISTEN状态，等待客户端连接请求。 第一次握手 TCP客户端先创建传输控制块PCB，然后向服务器B发送连接请求报文段，此时首部中的同步位SYN置位1，同时选择一个初始序号seq = x，这是TCP客户端进入SYN-SENT（同步已发送）状态。 第二次握手 服务器B收到A发送的连接请求报文段后，如果同意连接，则向A发送确认，在确认报文段中，将ACK和SYN都置为1，确认号是ack = x + 1，同时也为自己选择一个初始序号seq = y，这是TCP服务器进入SYN-RCVD（同步收到）状态。 第三次握手 TCP客户端收到B发送的确认后，还要向B给出确认，确认报文ACK置为1，确认号ack = y + 1，自己的序号为seq = x + 1。TCP协议规定，ACK报文段可以携带数据，如果不携带数据，则不消耗序号，则下一数据报文段的序号仍然为seq = x + 1，这时TCP已经建立连接，A进入ESTABLISHED（已建立连接状态）。当B收到A的确认后也进入ESTANLISHED状态。 上面这种建立连接的过程称为三次握手。 【面试问题1】为什么A还要再发送一次确认呢？ 这是为了防止某些失效的连接请求报文再次传送给服务器B而导致出错。失效连接报文来源？假如TCP连接就是两次握手，如果说客户端A给服务器端B发送了连接请求报文段，但是报文段丢失，导致B没有收到，于是A重传连接请求，第二次的服务器端B收到了连接请求，建立了连接。数据传输完成后就释放连接。在这个过程中，客户端A共发送两次连接请求报文，一个报文丢失，另一个报文到达了B。不存在“已失效的连接报文”。 现在考虑另一种特诉情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 四次挥手： 四次挥手是TCP释放连接的过程，具体过程请看下图分析。 完成数据传输后，通信的双方都可以释放连接，主机A、B先都处于ESTABLISHED状态。 第一次挥手 A的应用进程先向其TCP发送连接释放报文段，A停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的FIN置1，其序号seq = u，它等于前面已经传送过的数据的最后一个字节序号加1。这时A进入FIN-WAIT-1（终止等待1）状态，等待B的确认，注意：TCP规定，FIN报文段即使不携带数据也要消耗一个序号。 第二次挥手 B收到连接释放报文段后，立即发出确认，确认号是ask = u + 1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT（关闭等待）状态，TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP处于半关闭状态，即A已经没有数据要发送了，但B若要发送数据，A仍要接收，也就是说，从B到A的方向连接并灭有关闭。这个状态可能会持续一些时间。 第三次挥手 A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接请求释放报文段。 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使FIN = 1，现假定B的序号为w（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号akc = u + 1。这时B就进入LAST-ACK（最后确认）状态，等待A的确认。 第四次挥手 A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack = w + 1，而自己的序号是seq = u + 1（根据TCP标准，前面发送的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT）设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命。MSL是根据工程来设置时长的，假设为2min。因此从A进入到TIME-WAIT状态后，要经过4分钟才能进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。 【面试问题2】为什么A在TIME-WAIT状态必须等待2MSL的时间呢？ 这有两个原因：第一：为了保证A发送的最后一个ACK报文段能够到达B，这个报文段有可能丢失，因而使处在LAST-WAIT的状态B收不到对方已发送的FIN-ACK报文段的确认，B会超时重传这个FIN + ACK报文段，而A就能在2MSL时间内接收到这个重传的FIN + ACK报文段，接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TINE-WAIT装态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么久无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按正常步骤进入CLOSED状态。第二：防止上文提到的“已失效的连接请求报文”出现在本连接中。A发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到A发出的确认，就进入CLOSED状态，同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接，我们注意到，B结束TCP连接的时间要比A早一些。]]></content>
      <categories>
        <category>SO Kernals</category>
      </categories>
      <tags>
        <tag>ACK机制</tag>
        <tag>TCP连接过程</tag>
        <tag>TCP断开连接</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保证TCP协议的可靠传输]]></title>
    <url>%2Fblog%2F2018%2F05%2F31%2FTCp%E5%8D%8F%E8%AE%AE%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[写在前面 TCP协议在网络传输中保证了其可靠性，本篇文章对TCP协议可靠传输机制做了详细介绍，介绍：（ACK机制&amp;滑动窗口&amp;拥塞控制&amp;流量控制）。 回顾内容 传输层使用的两个主要协议：TCP和UDP TCP 主要特性有特性有以下几点： (1)面向连接，在数据传送前必须建立连接，在数据传送结束后必须释放连接。在一个TCP连接中，仅有两方进行彼此通信。广播和多播不能用于TCP。 (2)点对点，每一条TCP连接只能有两个端点。从socket角度来说，通信双方需要建立套接字，套接字由IP地址和端口号组成，数据到达传输层之后会被送到端口对应的应用程序。 (3)提供可靠交付服务。 (4)支持全双工通信。 (5)面向字节流。面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序数据看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。 总述1、确认应答（ACK）机制： 2、超时重传机制： 接收方收到报文就会确认，发送方发送一段时间后没有收到确认就重传。 3、滑动窗口机制： 4、数据校验： TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 5、数据合理分片和排序： UDP：IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片.把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便无法重组数据报.将导致丢弃整个UDP数据报. TCP会按MTU合理分片，接收方会缓存未按序到达的数据，重新排序后再交给应用层。 5、流量控制： 当接收方来不及处理发送方的数据，就提示发送方降低发送的速率，防止包丢失。 7、拥塞控制： 当网络拥塞时，减少数据的发送。 上面简单的讲了TCP保证可靠传输的几个机制，下面对较难理解的面深入探究。 滑动窗口滑动窗口是干什么的？有一种机制叫做ACK确认应答【过程如图】，收到数据段，给发送一个ACK确认应答，收到ACK应答后，再发送数据段，明显会降低效率，如果数据往返时间较长时，会影响到性能。 上面这种方式浪费效率，如果换种方式发送呢 ^_^ 一次发送多个数据段，统一确认后，再发送多个数据段。 上面这种传送机制就是窗口机制。 窗口是什么？ 窗口大小：就是无需等到确认应答而可以继续发送数据的最大值。（上图窗口就是4000字节，也就是四个段） 传输过程： 1、客户端和服务器端各自建立套接字，通过彼此的套接字进行通信； 2、服务器端绑定监听端口，然后监听，循环等待来自客户端的连接； 3、一旦收到来自客户端的连接，进行三次握手，一旦连成功就fork()一个子进程来处理和当前客户端的连接，然后父进程继续监听客户端的连接； 4、发送前面四个段，无需ACK确认应答，直接发送； 5、收到第一个ACK后，滑动窗口向后移动，发送第五个数据段，以此类推； 6、操作系统为了维护这个滑动窗口，需要开辟发送缓冲区来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉； 7、一旦数据传输完毕就是放连接。 就是说随着时间推移，滑动窗口也在推移，滑动窗口的会变化，内部缓存数据不停的更新，根据网络的拥塞情况，发送端可以调控滑动窗口的大小来控制流量 ，滑动窗口就是一个滑的过程啊~ ^* ~ ^* 可能解释的有点啰嗦了 4、窗口越大，网络吞吐量就越高。 吞吐量就是单位时间内通过某个网络（信道、接口）的数据量。 接收窗口大小取决于应用（比如说tomcat：8080端口的监听进程）、系统、硬件的限制。 流量控制简单来说就是接收方处理不过来的时候，就把窗口缩小，并把窗口值告诉发送端。 当窗口值为0，而接受方把窗口值恢复（比如ACK=1，ack=601，rwnd=200），但确认丢失，进入相互等待的死锁局面。所以如果窗口值为0，发送端就会开启一个持续计数器，每个一段时间询问一下接收方。 拥塞控制 什么是拥塞？ 是指计算机网络中，某一个时段，某一资源的需求量超过了该资源可提供的可用部分，网络性能变差。 什么是拥塞控制？ 所谓的拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或者节点不至于过载，拥塞控制是一个全局的过程。 几种拥塞控制的方法：因特网建议标准RFC定义了几种拥塞控制的算法； 满开始，拥塞避免， 快重传，快恢复。 拥塞控制描述： 唯一的方法就是尝试各种不同的发送速度。比如一开始以 100kb/s 的速率发送数据，如果没问题，再将速率提高到 200kb/s，再没问题继续提升发送速率。一旦达到某个上限后，便开始出现丢包现象，发送方就可以认为，网络已经拥塞了，于是降低发送速率，减轻网络负担。 控制流程简述： 慢开始、拥塞避免 发送方维持一个拥塞窗口的状态变量，其大小取决于网络的拥塞程度，动态地变化，而发送窗口一般取拥塞窗口和对方给出的接收窗口的最小值（为了便于描述，后面的分析中假定对方给出的接收窗口足够大，这样将发送窗口等于拥塞窗口就可以了）。 慢开始算法的核心是从小到大逐渐增大发送窗口，也就是说，从小到大逐渐增大拥塞窗口的数值。通常在刚开始发送报文段时，先把拥塞窗口设置为一个最大报文段MSS的数值，而在每收到对上一轮报文段（，每次加倍后的报文段的个数，可能不止一个报文段）的确认后，就把拥塞窗口的数值加倍。 为了防止拥塞窗口增长过大引起网络拥塞，还需要维护一个慢开始门限的状态变量，当拥塞窗口的值小于慢开始门限时，使用慢开始算法，一旦拥塞窗口的值大于慢开始门限的值，就改用拥塞避免算法。 拥塞避免算法的思路是让拥塞窗口缓慢地增大，收到每一轮的确认后，将拥塞窗口的值加1，而不是加倍，这样拥塞窗口的值按照线性规律缓慢增长。 无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（没有按时收到确认），就把慢开始门限设置为出现拥塞时发送窗口值的一般，但最小不能小于2个MSS值，而后把拥塞窗口的值重新设置为1个MSS，执行慢开始算法。 快重传，快恢复 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（重复发送对前面有序部分的确认），而不是等待自己发送数据时才进行稍待确认，也不是累积收到的报文发送累积确认，如果发送方连续收到三个重复确认，就应该立即重传对方未收到的报文段（有收到重复确认，说明后面的报文段都送达了，只有中间丢失的报文段没送达）。 快恢复算法与快重传算法配合使用，其过程有如下两个要点： 1、当发送方连续收到三个重复确认时，就把慢开始门限减半，这是为了预防网络发生拥塞。注意，接下来不执行慢开始算法。 2、由于发送方现在认为网络很很可能没有发生特别严重的阻塞（如果发生了严重阻塞的话，就不会一连有好几个报文段到达接收方，就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口的值不设为1个MSSS），而是把拥塞窗口的值设为慢开始门限减半后的值，而后开始执行拥塞避免算法，线性地增大拥塞窗口。 问题思考1、网络拥堵是怎么来的？ 2、RFC 定义的 4 种拥塞控制算法是什么？分别讲述流程以及原理？ 3、为什么TCP传输这么复杂？ 因为要保证可靠传输，同时又要尽可能提高性能。]]></content>
      <categories>
        <category>SO Kernal</category>
      </categories>
      <tags>
        <tag>ACK机制</tag>
        <tag>TCP协议</tag>
        <tag>滑动窗口</tag>
        <tag>拥塞控制</tag>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP协议实现回显服务器]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2F%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[写在前面 回显服务器的代码实现过程，文章加入了详细的设计过程以及其他的计算机网络理论知识。操作环境：CentOS 7.0 X64 操作系统、Vim编辑器、Gcc编译器。 预备知识 本文的目的是写回显服务器，在撸代码之前，先来个热身。 IP地址是什么IP地址有IPV4、IPV6之分，一般不特俗说明，默认就是IPV4。 IP地址是用来标识不同的主机，每个主机都有唯一的IP地址；对于IP4来说，IP地址是一个4字节，32位整数；IP地址用“点分”制表示，如：192.168.1.11（用点分割的每个数范围0~255）。 源IP地址&amp;目的IP地址 很容易理解，都是地址，和寄快递的收发地址一样，从上海发往西安的快递，源IP就是上海，目的IP就是西安。 端口号是什么 端口号是传输层协议内容 端口号是2字节196位整数；端口号用来标识一个进程，告诉操作系统，当前数据要交给哪一个进程来处理；一个进程可以绑定多个端口号，但是一个端口号不可以绑定多个进程。 源端口号&amp;目的端口号 在源IP&amp;目的IP中，我们用的寄快递的例子帮助理解，在这里，还是用发快递帮助理解。源IP与目的IP标识了发件人地址和收件人的地址，地址有了，那么包裹就会交给快递员运送每个，快递员都有一个工号，工号是唯一的。这就对应了数据传输过程中，由哪个进程来处理数据。再来到寄快递问题上，有的快递包裹比较大，这就要多个快递员来运输，那么一个包裹由多个快递员运输，记在物流信息上就是这样的格式：一个包裹的目的地 + 多个快递员工号；这家公司接的都是大包裹，一个快递员只能送一个包裹。对应到网络传输中，就是一个进程可以绑定多个端口号，但一个端口号不可以绑定多个进程。 函数介绍 为后面撸代码介绍几个函数。 网络字节序：在C语言中我们知道，内存中的数据存储有大小端之分；数据在磁盘中存储也有大小端之分，在这里我还想啰嗦一个C语言问题，怎样判断自己的计算机内存是大端字节序还是小端字节序存储方式？[假装思索……] 大小端判断很有可能成为你将来的面试题。以前我总结过这样的问题。 以后再附上链接：哈哈 （只想引入下面一句话）在网络数据流中同样有大小端之分，那么如何定义网络数据流的地址呢？ 【看图理解】 【看图说话】 如果发送主机是小端，就要准换成大端再发送，如果是大端，直接发送即可。 为了使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。 12345#include&lt;arpa/inet.h&gt; uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); 调用函数就能解决存储字节序不统一的问题 socket编程常见API：这部分只把函数列出来，详细介绍请戳作者下面博客： 请戳： socket套接字总结 123456789//创建socket文件描述符 (TCP/UDP,客户端+服务器)int socket(int domain, int type, int protocol);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);//关闭套接字int close(int fd); sockaddr结构： socket API是一 层抽象的网络编程接口 ,适用于各种底层网络协议,如IPv4、IPv6.然而, 各种网络协议的地址格式各不相同。 注意：socket API可以都用 struct sockaddr *类型表 , 在使用的时候需要强制转化成sockaddr_in; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数。 UDP协议 通过上面的学习对UDP有个直观的认识，再详细讨论以下几点： 无连接 知道目的端的IP和端口号就能传输，不需要建立连接。 不可靠传输 没有确认机制，没有重传机制，如果因为网络故障无法发送到对方，UDP协议层也不会给应用层返回任何错误信息。 面向数据报 不能够灵活的控制读写数据的次数和数量。 以上几点在代码中还能得到学习和理解。 服务器和客户端是怎么运行起来的？先说说什么是回显服务器： 回显服务器是最简单的服务器，客户端发起请求，服务器收到请求，然后客户端发送什么内容，服务器就给客户端返回什么内容。 服务器： 1、创建socket 2、绑定端口 3、循环的读取数据 4、针对读取到的数据进行计算和处理 5、把处理后的结果发回客户端 客户端： 1、创建socket文件 2、给服务器发送请求 3、从服务器中读取结果。 有了步骤，实现起来就只需要把步骤翻译成Code了： 服务器实现123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;sys/socket.h&gt;int main()&#123; //创建一个套接字，并检测是否创建成功 int sockSer = socket(AF_INET, SOCK_DGRAM, 0); if(sockSer == -1) perror("socket"); struct sockaddr_in addrSer; //创建一个记录地址信息的结构体 addrSer.sin_family = AF_INET; //使用AF_INET协议族 addrSer.sin_port = htons(5050); //设置地址结构体中的端口号 addrSer.sin_addr.s_addr = inet_addr("192.168.3.169"); //设置通信ip //将套接字地址与所创建的套接字号联系起来，并检测是否绑定成功 socklen_t addrlen = sizeof(struct sockaddr); int res = bind(sockSer,(struct sockaddr*)&amp;addrSer, addrlen); if(res == -1) perror("bind"); char sendbuf[256]; //申请一个发送数据缓存区 char recvbuf[256]; //申请一个接收数据缓存区 struct sockaddr_in addrCli; while(1) //服务器一直循环接受客户端的请求 &#123; recvfrom(sockSer,recvbuf,256,0,(struct sockaddr*)&amp;addrCli, &amp;addrlen); //从指定地址接收客户端数据 printf("Cli:&gt;%s\n",recvbuf); printf("Ser:&gt;"); scanf("%s",sendbuf); sendto(sockSer,sendbuf,strlen(sendbuf)+1,0,(struct sockaddr*)&amp;addrCli, addrlen); //向客户端发送数据 &#125; return 0;&#125; 客户端实现1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;sys/socket.h&gt;int main()&#123; //创建一个套接字，并检测是否创建成功 int sockCli = socket(AF_INET, SOCK_DGRAM, 0); if(sockCli == -1)&#123; perror("socket"); &#125; addrSer.sin_family = AF_INET; //使用AF_INET协议族 addrSer.sin_port = htons(5050); //设置地址结构体中的端口号 addrSer.sin_addr.s_addr = inet_addr("192.168.3.169"); //设置通信ip socklen_t addrlen = sizeof(struct sockaddr); char sendbuf[256]; //申请一个发送数据缓存区 char recvbuf[256]; //申请一个接收数据缓存区 while(1)&#123; //向客户端发送数据 printf("Cli:&gt;"); scanf("%s",sendbuf); sendto(sockCli, sendbuf, strlen(sendbuf)+1, 0, (struct sockaddr*)&amp;addrSer, addrlen); 接收来自客户端的数据 recvfrom(sockCli, recvbuf, BUFFER_SIZE, 0, (struct sockaddr*)&amp;addrSer, &amp;addrlen); printf("Ser:&gt;%s\n", recvbuf); &#125; return 0;&#125; 问题思考1、UDP协议的特点以及和TCP协议的区别？ 2、UDP连接建立过程分析、TCP呢？ 3、UDP协议是不可靠的，为什么还要使用？]]></content>
      <categories>
        <category>SO Kernal</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>UDP协议</tag>
        <tag>回显服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHub + Blog【版本：小猪佩奇】]]></title>
    <url>%2Fblog%2F2018%2F05%2F20%2FHexo%2BGitHub%20Blog%2F</url>
    <content type="text"><![CDATA[写在前面 利用周末时间搭建了Hexo + github + 个性化域名博客 通过不断地测试和完善，实现了常用功能以及基本的页面美化 问题概况 在搭建过程中遇到了很多棘手的问题，在中途因为没有测试，还崩溃过，只能归零，从头再来。 非常感谢众多大神的博客，给了我很多帮助，推荐几个程序员技术交流网站/社区：知乎、简书、CSDN、掘金、牛客、GitHub。 因为有了第一次的经验和教训，所以第二次从环境搭建到站点/主题配置就一气呵成了。 我的博客后期用来管理优质文章、自己写的小项目、分享我喜欢的图片、音乐歌单、笔记等等，欢迎读者收藏。 工具推荐1、Atom 2、Sublime Text 3 3、NotePad ++ 4、冰点文库下载器 5、LastActivity View 6、Xshell 7、Xftp 6 8、Mind Master 9、Fiddler 10、VC++ 6.0 MSDN 11、Typora]]></content>
      <categories>
        <category>工具操作</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
        <tag>Githubpage</tag>
        <tag>随想</tag>
        <tag>程序员常用工具</tag>
      </tags>
  </entry>
</search>
